From 06198e50aac9e772d51d0cf82c037aea3e574295 Mon Sep 17 00:00:00 2001
From: Yogesh Gaur <yogeshnarayan.gaur@nxp.com>
Date: Wed, 15 Nov 2017 11:59:31 +0530
Subject: [PATCH 022/129] driver: net: fsl-mc: flib changes for MC 10.3.0

Existing MC driver framework is based on MC-9.x.x flib. This patch
migrates MC obj (DPBP, DPNI, DPRC, DPMAC etc) to use latest MC flib
which is MC-10.3.0.

Changes introduced due to migration:
1. To get OBJ token, pair of create and open API replaces create APIs
2. Pair of close and destroy APIs replaces destroy APIs
3. For version read, get_version APIs replaces get_attributes APIs
4. dpni_get/reset_statistics APIs replaces dpni_get/set_counter APIs
5. Simplifies struct dpni_cfg and removes dpni_extended_cfg struct
6. Single API dpni_get_buffer_layout/set_buffer_layout replaces
   dpni_get_rx/set_rx, tx related, tx_conf_buffer_layout related APIs.
   New API takes a queue type as an argument.
7. Similarly dpni_get_queue/set_queue replaces
   dpni_get_rx_flow/set_rx_flow , tx_flow related, tx_conf related
   APIs

Signed-off-by: Yogesh Gaur <yogeshnarayan.gaur@nxp.com>
Signed-off-by: Priyanka Jain <priyanka.jain@nxp.com>
Reviewed-by: York Sun <york.sun@nxp.com>
---
 drivers/net/fsl-mc/dpbp.c          |   42 ++-
 drivers/net/fsl-mc/dpio/dpio.c     |   43 ++-
 drivers/net/fsl-mc/dpmac.c         |   41 ++-
 drivers/net/fsl-mc/dpni.c          |  332 +++--------
 drivers/net/fsl-mc/dprc.c          |   27 +-
 drivers/net/fsl-mc/fsl_dpmng_cmd.h |    5 +-
 drivers/net/fsl-mc/mc.c            |  237 +++++---
 drivers/net/ldpaa_eth/ldpaa_eth.c  |  283 ++++++-----
 drivers/net/ldpaa_eth/ldpaa_eth.h  |    5 +-
 include/fsl-mc/fsl_dpbp.h          |   62 ++-
 include/fsl-mc/fsl_dpio.h          |   64 ++-
 include/fsl-mc/fsl_dpmac.h         |   69 ++-
 include/fsl-mc/fsl_dpni.h          | 1065 ++++++++++++------------------------
 include/fsl-mc/fsl_dprc.h          |   79 ++--
 include/fsl-mc/fsl_mc_cmd.h        |   50 ++-
 include/fsl-mc/fsl_mc_private.h    |    8 +-
 16 files changed, 1085 insertions(+), 1327 deletions(-)

diff --git a/drivers/net/fsl-mc/dpbp.c b/drivers/net/fsl-mc/dpbp.c
index ba9536d..a0552f4 100644
--- a/drivers/net/fsl-mc/dpbp.c
+++ b/drivers/net/fsl-mc/dpbp.c
@@ -1,8 +1,8 @@
 /*
  * Freescale Layerscape MC I/O wrapper
  *
- * Copyright (C) 2013-2015 Freescale Semiconductor, Inc.
- * Author: German Rivera <German.Rivera@freescale.com>
+ * Copyright (C) 2013-2016 Freescale Semiconductor, Inc.
+ * Copyright 2017 NXP
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -50,9 +50,10 @@ int dpbp_close(struct fsl_mc_io *mc_io,
 }
 
 int dpbp_create(struct fsl_mc_io *mc_io,
+		uint16_t dprc_token,
 		uint32_t cmd_flags,
 		const struct dpbp_cfg *cfg,
-		uint16_t *token)
+		uint32_t *obj_id)
 {
 	struct mc_command cmd = { 0 };
 	int err;
@@ -62,7 +63,7 @@ int dpbp_create(struct fsl_mc_io *mc_io,
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPBP_CMDID_CREATE,
 					  cmd_flags,
-					  0);
+					  dprc_token);
 
 	/* send command to mc*/
 	err = mc_send_command(mc_io, &cmd);
@@ -70,21 +71,25 @@ int dpbp_create(struct fsl_mc_io *mc_io,
 		return err;
 
 	/* retrieve response parameters */
-	*token = MC_CMD_HDR_READ_TOKEN(cmd.header);
+	MC_CMD_READ_OBJ_ID(cmd, *obj_id);
 
 	return 0;
 }
 
 int dpbp_destroy(struct fsl_mc_io *mc_io,
+		 uint16_t dprc_token,
 		 uint32_t cmd_flags,
-		 uint16_t token)
+		 uint32_t obj_id)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPBP_CMDID_DESTROY,
 					  cmd_flags,
-					  token);
+					  dprc_token);
+
+	/* set object id to destroy */
+	CMD_DESTROY_SET_OBJ_ID_PARAM0(cmd, obj_id);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
@@ -157,3 +162,26 @@ int dpbp_get_attributes(struct fsl_mc_io *mc_io,
 
 	return 0;
 }
+
+int dpbp_get_api_version(struct fsl_mc_io *mc_io,
+			 u32 cmd_flags,
+			 u16 *major_ver,
+			 u16 *minor_ver)
+{
+	struct mc_command cmd = { 0 };
+	int err;
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPBP_CMDID_GET_API_VERSION,
+					  cmd_flags, 0);
+
+	/* send command to mc */
+	err = mc_send_command(mc_io, &cmd);
+	if (err)
+		return err;
+
+	/* retrieve response parameters */
+	mc_cmd_read_api_version(&cmd, major_ver, minor_ver);
+
+	return 0;
+}
diff --git a/drivers/net/fsl-mc/dpio/dpio.c b/drivers/net/fsl-mc/dpio/dpio.c
index b61df52..ccac506 100644
--- a/drivers/net/fsl-mc/dpio/dpio.c
+++ b/drivers/net/fsl-mc/dpio/dpio.c
@@ -1,5 +1,6 @@
 /*
- * Copyright (C) 2013-2015 Freescale Semiconductor
+ * Copyright (C) 2013-2016 Freescale Semiconductor
+ * Copyright 2017 NXP
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -10,7 +11,7 @@
 
 int dpio_open(struct fsl_mc_io *mc_io,
 	      uint32_t cmd_flags,
-	      int dpio_id,
+	      uint32_t dpio_id,
 	      uint16_t *token)
 {
 	struct mc_command cmd = { 0 };
@@ -49,9 +50,10 @@ int dpio_close(struct fsl_mc_io *mc_io,
 }
 
 int dpio_create(struct fsl_mc_io *mc_io,
+		uint16_t dprc_token,
 		uint32_t cmd_flags,
 		const struct dpio_cfg *cfg,
-		uint16_t *token)
+		uint32_t *obj_id)
 {
 	struct mc_command cmd = { 0 };
 	int err;
@@ -59,7 +61,7 @@ int dpio_create(struct fsl_mc_io *mc_io,
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPIO_CMDID_CREATE,
 					  cmd_flags,
-					  0);
+					  dprc_token);
 	DPIO_CMD_CREATE(cmd, cfg);
 
 	/* send command to mc*/
@@ -68,21 +70,25 @@ int dpio_create(struct fsl_mc_io *mc_io,
 		return err;
 
 	/* retrieve response parameters */
-	*token = MC_CMD_HDR_READ_TOKEN(cmd.header);
+	MC_CMD_READ_OBJ_ID(cmd, *obj_id);
 
 	return 0;
 }
 
 int dpio_destroy(struct fsl_mc_io *mc_io,
+		 uint16_t dprc_token,
 		 uint32_t cmd_flags,
-		 uint16_t token)
+		 uint32_t obj_id)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPIO_CMDID_DESTROY,
 					  cmd_flags,
-					  token);
+					  dprc_token);
+
+	/* set object id to destroy */
+	CMD_DESTROY_SET_OBJ_ID_PARAM0(cmd, obj_id);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
@@ -156,3 +162,26 @@ int dpio_get_attributes(struct fsl_mc_io *mc_io,
 
 	return 0;
 }
+
+int dpio_get_api_version(struct fsl_mc_io *mc_io,
+			 u32 cmd_flags,
+			 u16 *major_ver,
+			 u16 *minor_ver)
+{
+	struct mc_command cmd = { 0 };
+	int err;
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPIO_CMDID_GET_API_VERSION,
+					  cmd_flags, 0);
+
+	/* send command to mc */
+	err = mc_send_command(mc_io, &cmd);
+	if (err)
+		return err;
+
+	/* retrieve response parameters */
+	mc_cmd_read_api_version(&cmd, major_ver, minor_ver);
+
+	return 0;
+}
diff --git a/drivers/net/fsl-mc/dpmac.c b/drivers/net/fsl-mc/dpmac.c
index 072a90d..a719ac1 100644
--- a/drivers/net/fsl-mc/dpmac.c
+++ b/drivers/net/fsl-mc/dpmac.c
@@ -1,7 +1,8 @@
 /*
  * Freescale Layerscape MC I/O wrapper
  *
- * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
+ * Copyright 2017 NXP
  * Author: Prabhakar Kushwaha <prabhakar@freescale.com>
  *
  * SPDX-License-Identifier:	GPL-2.0+
@@ -51,9 +52,10 @@ int dpmac_close(struct fsl_mc_io *mc_io,
 }
 
 int dpmac_create(struct fsl_mc_io *mc_io,
+		 uint16_t dprc_token,
 		 uint32_t cmd_flags,
 		 const struct dpmac_cfg *cfg,
-		 uint16_t *token)
+		 uint32_t *obj_id)
 {
 	struct mc_command cmd = { 0 };
 	int err;
@@ -61,7 +63,7 @@ int dpmac_create(struct fsl_mc_io *mc_io,
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPMAC_CMDID_CREATE,
 					  cmd_flags,
-					  0);
+					  dprc_token);
 	DPMAC_CMD_CREATE(cmd, cfg);
 
 	/* send command to mc*/
@@ -70,21 +72,25 @@ int dpmac_create(struct fsl_mc_io *mc_io,
 		return err;
 
 	/* retrieve response parameters */
-	*token = MC_CMD_HDR_READ_TOKEN(cmd.header);
+	MC_CMD_READ_OBJ_ID(cmd, *obj_id);
 
 	return 0;
 }
 
 int dpmac_destroy(struct fsl_mc_io *mc_io,
+		  uint16_t dprc_token,
 		  uint32_t cmd_flags,
-		  uint16_t token)
+		  uint32_t obj_id)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPMAC_CMDID_DESTROY,
 					  cmd_flags,
-					  token);
+					  dprc_token);
+
+	/* set object id to destroy */
+	CMD_DESTROY_SET_OBJ_ID_PARAM0(cmd, obj_id);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
@@ -220,3 +226,26 @@ int dpmac_get_counter(struct fsl_mc_io *mc_io,
 
 	return 0;
 }
+
+int dpmac_get_api_version(struct fsl_mc_io *mc_io,
+			 u32 cmd_flags,
+			 u16 *major_ver,
+			 u16 *minor_ver)
+{
+	struct mc_command cmd = { 0 };
+	int err;
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPMAC_CMDID_GET_API_VERSION,
+					  cmd_flags, 0);
+
+	/* send command to mc */
+	err = mc_send_command(mc_io, &cmd);
+	if (err)
+		return err;
+
+	/* retrieve response parameters */
+	mc_cmd_read_api_version(&cmd, major_ver, minor_ver);
+
+	return 0;
+}
diff --git a/drivers/net/fsl-mc/dpni.c b/drivers/net/fsl-mc/dpni.c
index 41bf56a..481f9d8 100644
--- a/drivers/net/fsl-mc/dpni.c
+++ b/drivers/net/fsl-mc/dpni.c
@@ -1,5 +1,6 @@
 /*
- * Copyright (C) 2013-2015 Freescale Semiconductor
+ * Copyright (C) 2013-2016 Freescale Semiconductor
+ * Copyright 2017 NXP
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -8,22 +9,22 @@
 #include <fsl-mc/fsl_mc_cmd.h>
 #include <fsl-mc/fsl_dpni.h>
 
-int dpni_prepare_extended_cfg(const struct dpni_extended_cfg	*cfg,
-			      uint8_t			*ext_cfg_buf)
+int dpni_prepare_cfg(const struct dpni_cfg	*cfg,
+		     uint8_t			*cfg_buf)
 {
-	uint64_t *ext_params = (uint64_t *)ext_cfg_buf;
+	uint64_t *params = (uint64_t *)cfg_buf;
 
-	DPNI_PREP_EXTENDED_CFG(ext_params, cfg);
+	DPNI_PREP_CFG(params, cfg);
 
 	return 0;
 }
 
-int dpni_extract_extended_cfg(struct dpni_extended_cfg	*cfg,
-			      const uint8_t		*ext_cfg_buf)
+int dpni_extract_cfg(struct dpni_cfg	*cfg,
+		     const uint8_t	*cfg_buf)
 {
-	uint64_t *ext_params = (uint64_t *)ext_cfg_buf;
+	uint64_t *params = (uint64_t *)cfg_buf;
 
-	DPNI_EXT_EXTENDED_CFG(ext_params, cfg);
+	DPNI_EXT_CFG(params, cfg);
 
 	return 0;
 }
@@ -69,9 +70,10 @@ int dpni_close(struct fsl_mc_io *mc_io,
 }
 
 int dpni_create(struct fsl_mc_io *mc_io,
+		uint16_t dprc_token,
 		uint32_t cmd_flags,
 		const struct dpni_cfg *cfg,
-		uint16_t *token)
+		uint32_t *obj_id)
 {
 	struct mc_command cmd = { 0 };
 	int err;
@@ -79,7 +81,7 @@ int dpni_create(struct fsl_mc_io *mc_io,
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_CREATE,
 					  cmd_flags,
-					  0);
+					  dprc_token);
 	DPNI_CMD_CREATE(cmd, cfg);
 
 	/* send command to mc*/
@@ -88,21 +90,25 @@ int dpni_create(struct fsl_mc_io *mc_io,
 		return err;
 
 	/* retrieve response parameters */
-	*token = MC_CMD_HDR_READ_TOKEN(cmd.header);
+	 MC_CMD_READ_OBJ_ID(cmd, *obj_id);
 
 	return 0;
 }
 
 int dpni_destroy(struct fsl_mc_io *mc_io,
+		 uint16_t dprc_token,
 		 uint32_t cmd_flags,
-		 uint16_t token)
+		 uint32_t obj_id)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_DESTROY,
 					  cmd_flags,
-					  token);
+					  dprc_token);
+
+	/* set object id to destroy */
+	CMD_DESTROY_SET_OBJ_ID_PARAM0(cmd, obj_id);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
@@ -182,8 +188,6 @@ int dpni_get_attributes(struct fsl_mc_io *mc_io,
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_ATTR,
 					  cmd_flags,
 					  token);
-	DPNI_CMD_GET_ATTR(cmd, attr);
-
 	/* send command to mc*/
 	err = mc_send_command(mc_io, &cmd);
 	if (err)
@@ -212,124 +216,19 @@ int dpni_set_errors_behavior(struct fsl_mc_io *mc_io,
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpni_get_rx_buffer_layout(struct fsl_mc_io *mc_io,
-			      uint32_t cmd_flags,
-			      uint16_t token,
-			      struct dpni_buffer_layout *layout)
-{
-	struct mc_command cmd = { 0 };
-	int err;
-
-	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_RX_BUFFER_LAYOUT,
-					  cmd_flags,
-					  token);
-
-	/* send command to mc*/
-	err = mc_send_command(mc_io, &cmd);
-	if (err)
-		return err;
-
-	/* retrieve response parameters */
-	DPNI_RSP_GET_RX_BUFFER_LAYOUT(cmd, layout);
-
-	return 0;
-}
-
-int dpni_set_rx_buffer_layout(struct fsl_mc_io *mc_io,
-			      uint32_t cmd_flags,
-			      uint16_t token,
-			      const struct dpni_buffer_layout *layout)
+int dpni_set_buffer_layout(struct fsl_mc_io *mc_io,
+			   uint32_t cmd_flags,
+			   uint16_t token,
+			   const struct dpni_buffer_layout *layout,
+			   enum dpni_queue_type type)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_RX_BUFFER_LAYOUT,
+	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_BUFFER_LAYOUT,
 					  cmd_flags,
 					  token);
-	DPNI_CMD_SET_RX_BUFFER_LAYOUT(cmd, layout);
-
-	/* send command to mc*/
-	return mc_send_command(mc_io, &cmd);
-}
-
-int dpni_get_tx_buffer_layout(struct fsl_mc_io *mc_io,
-			      uint32_t cmd_flags,
-			      uint16_t token,
-			      struct dpni_buffer_layout *layout)
-{
-	struct mc_command cmd = { 0 };
-	int err;
-
-	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_TX_BUFFER_LAYOUT,
-					  cmd_flags,
-					  token);
-
-	/* send command to mc*/
-	err = mc_send_command(mc_io, &cmd);
-	if (err)
-		return err;
-
-	/* retrieve response parameters */
-	DPNI_RSP_GET_TX_BUFFER_LAYOUT(cmd, layout);
-
-	return 0;
-}
-
-int dpni_set_tx_buffer_layout(struct fsl_mc_io *mc_io,
-			      uint32_t cmd_flags,
-			      uint16_t token,
-			      const struct dpni_buffer_layout *layout)
-{
-	struct mc_command cmd = { 0 };
-
-	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_TX_BUFFER_LAYOUT,
-					  cmd_flags,
-					  token);
-	DPNI_CMD_SET_TX_BUFFER_LAYOUT(cmd, layout);
-
-	/* send command to mc*/
-	return mc_send_command(mc_io, &cmd);
-}
-
-int dpni_get_tx_conf_buffer_layout(struct fsl_mc_io *mc_io,
-				   uint32_t cmd_flags,
-				   uint16_t token,
-				   struct dpni_buffer_layout *layout)
-{
-	struct mc_command cmd = { 0 };
-	int err;
-
-	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_TX_CONF_BUFFER_LAYOUT,
-					  cmd_flags,
-					  token);
-
-	/* send command to mc*/
-	err = mc_send_command(mc_io, &cmd);
-	if (err)
-		return err;
-
-	/* retrieve response parameters */
-	DPNI_RSP_GET_TX_CONF_BUFFER_LAYOUT(cmd, layout);
-
-	return 0;
-}
-
-int dpni_set_tx_conf_buffer_layout(struct fsl_mc_io *mc_io,
-				   uint32_t cmd_flags,
-				   uint16_t token,
-				   const struct dpni_buffer_layout *layout)
-{
-	struct mc_command cmd = { 0 };
-
-	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_TX_CONF_BUFFER_LAYOUT,
-					  cmd_flags,
-					  token);
-	DPNI_CMD_SET_TX_CONF_BUFFER_LAYOUT(cmd, layout);
+	DPNI_CMD_SET_BUFFER_LAYOUT(cmd, layout, type);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
@@ -383,50 +282,6 @@ int dpni_get_tx_data_offset(struct fsl_mc_io *mc_io,
 	return 0;
 }
 
-int dpni_get_counter(struct fsl_mc_io *mc_io,
-		     uint32_t cmd_flags,
-		     uint16_t token,
-		     enum dpni_counter counter,
-		     uint64_t *value)
-{
-	struct mc_command cmd = { 0 };
-	int err;
-
-	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_COUNTER,
-					  cmd_flags,
-					  token);
-	DPNI_CMD_GET_COUNTER(cmd, counter);
-
-	/* send command to mc*/
-	err = mc_send_command(mc_io, &cmd);
-	if (err)
-		return err;
-
-	/* retrieve response parameters */
-	DPNI_RSP_GET_COUNTER(cmd, *value);
-
-	return 0;
-}
-
-int dpni_set_counter(struct fsl_mc_io *mc_io,
-		     uint32_t cmd_flags,
-		     uint16_t token,
-		     enum dpni_counter counter,
-		     uint64_t value)
-{
-	struct mc_command cmd = { 0 };
-
-	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_COUNTER,
-					  cmd_flags,
-					  token);
-	DPNI_CMD_SET_COUNTER(cmd, counter, value);
-
-	/* send command to mc*/
-	return mc_send_command(mc_io, &cmd);
-}
-
 int dpni_set_link_cfg(struct fsl_mc_io *mc_io,
 		      uint32_t cmd_flags,
 		      uint16_t token,
@@ -544,46 +399,64 @@ int dpni_remove_mac_addr(struct fsl_mc_io *mc_io,
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpni_set_tx_flow(struct fsl_mc_io *mc_io,
-		     uint32_t cmd_flags,
-		     uint16_t token,
-		     uint16_t *flow_id,
-		     const struct dpni_tx_flow_cfg *cfg)
+int dpni_get_api_version(struct fsl_mc_io *mc_io,
+			 u32 cmd_flags,
+			 u16 *major_ver,
+			 u16 *minor_ver)
 {
 	struct mc_command cmd = { 0 };
 	int err;
 
 	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_TX_FLOW,
-					  cmd_flags,
-					  token);
-	DPNI_CMD_SET_TX_FLOW(cmd, *flow_id, cfg);
+	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_API_VERSION,
+					  cmd_flags, 0);
 
-	/* send command to mc*/
+	/* send command to mc */
 	err = mc_send_command(mc_io, &cmd);
 	if (err)
 		return err;
 
 	/* retrieve response parameters */
-	DPNI_RSP_SET_TX_FLOW(cmd, *flow_id);
+	mc_cmd_read_api_version(&cmd, major_ver, minor_ver);
 
 	return 0;
 }
 
-int dpni_get_tx_flow(struct fsl_mc_io *mc_io,
-		     uint32_t cmd_flags,
-		     uint16_t token,
-		     uint16_t flow_id,
-		     struct dpni_tx_flow_attr *attr)
+int dpni_set_queue(struct fsl_mc_io *mc_io,
+	uint32_t cmd_flags,
+	uint16_t token,
+	enum dpni_queue_type type,
+	uint8_t tc,
+	uint8_t index,
+	const struct dpni_queue *queue)
+{
+	struct mc_command cmd = { 0 };
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_QUEUE,
+					  cmd_flags,
+					  token);
+	DPNI_CMD_SET_QUEUE(cmd, type, tc, index, queue);
+
+	/* send command to mc*/
+	return mc_send_command(mc_io, &cmd);
+}
+
+int dpni_get_queue(struct fsl_mc_io *mc_io,
+	uint32_t cmd_flags,
+	uint16_t token,
+	enum dpni_queue_type type,
+	uint8_t tc,
+	uint8_t index,
+	struct dpni_queue *queue)
 {
 	struct mc_command cmd = { 0 };
 	int err;
 
 	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_TX_FLOW,
+	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_QUEUE,
 					  cmd_flags,
 					  token);
-	DPNI_CMD_GET_TX_FLOW(cmd, flow_id);
+	DPNI_CMD_GET_QUEUE(cmd, type, tc, index);
 
 	/* send command to mc*/
 	err = mc_send_command(mc_io, &cmd);
@@ -591,44 +464,43 @@ int dpni_get_tx_flow(struct fsl_mc_io *mc_io,
 		return err;
 
 	/* retrieve response parameters */
-	DPNI_RSP_GET_TX_FLOW(cmd, attr);
-
+	DPNI_RSP_GET_QUEUE(cmd, queue);
 	return 0;
 }
 
-int dpni_set_rx_flow(struct fsl_mc_io *mc_io,
-		     uint32_t cmd_flags,
-		     uint16_t token,
-		     uint8_t tc_id,
-		     uint16_t flow_id,
-		     const struct dpni_queue_cfg *cfg)
+int dpni_set_tx_confirmation_mode(struct fsl_mc_io *mc_io,
+	uint32_t cmd_flags,
+	uint16_t token,
+	enum dpni_confirmation_mode mode)
 {
+	struct dpni_tx_confirmation_mode *cmd_params;
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_RX_FLOW,
+	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_TX_CONFIRMATION_MODE,
 					  cmd_flags,
 					  token);
-	DPNI_CMD_SET_RX_FLOW(cmd, tc_id, flow_id, cfg);
+
+	cmd_params = (struct dpni_tx_confirmation_mode *)cmd.params;
+	cmd_params->confirmation_mode = mode;
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpni_get_rx_flow(struct fsl_mc_io *mc_io,
-		     uint32_t cmd_flags,
-		     uint16_t token,
-		     uint8_t tc_id,
-		     uint16_t flow_id,
-		     struct dpni_queue_attr *attr)
+int dpni_get_statistics(struct fsl_mc_io *mc_io,
+			uint32_t cmd_flags,
+			uint16_t token,
+			uint8_t  page,
+			struct dpni_statistics *stat)
 {
 	struct mc_command cmd = { 0 };
 	int err;
+
 	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_RX_FLOW,
-					  cmd_flags,
-					  token);
-	DPNI_CMD_GET_RX_FLOW(cmd, tc_id, flow_id);
+	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_STATISTICS,
+					  cmd_flags, token);
+	DPNI_CMD_GET_STATISTICS(cmd, page);
 
 	/* send command to mc*/
 	err = mc_send_command(mc_io, &cmd);
@@ -636,50 +508,22 @@ int dpni_get_rx_flow(struct fsl_mc_io *mc_io,
 		return err;
 
 	/* retrieve response parameters */
-	DPNI_RSP_GET_RX_FLOW(cmd, attr);
+	DPNI_RSP_GET_STATISTICS(cmd, stat);
 
 	return 0;
 }
 
-int dpni_set_tx_conf(struct fsl_mc_io	*mc_io,
-		     uint32_t		cmd_flags,
-		     uint16_t		token,
-		     uint16_t		flow_id,
-		     const struct dpni_tx_conf_cfg	*cfg)
+int dpni_reset_statistics(struct fsl_mc_io *mc_io,
+			  uint32_t cmd_flags,
+			  uint16_t token)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_TX_CONF,
-					  cmd_flags,
-					  token);
-	DPNI_CMD_SET_TX_CONF(cmd, flow_id, cfg);
+	cmd.header = mc_encode_cmd_header(DPNI_CMDID_RESET_STATISTICS,
+					  cmd_flags, token);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpni_get_tx_conf(struct fsl_mc_io		*mc_io,
-		     uint32_t			cmd_flags,
-		     uint16_t			token,
-		     uint16_t			flow_id,
-		     struct dpni_tx_conf_attr	*attr)
-{
-	struct mc_command cmd = { 0 };
-	int err;
-
-	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_TX_CONF,
-					  cmd_flags,
-					  token);
-	DPNI_CMD_GET_TX_CONF(cmd, flow_id);
-
-	/* send command to mc*/
-	err = mc_send_command(mc_io, &cmd);
-	if (err)
-		return err;
-
-	DPNI_RSP_GET_TX_CONF(cmd, attr);
-
-	return 0;
-}
diff --git a/drivers/net/fsl-mc/dprc.c b/drivers/net/fsl-mc/dprc.c
index 7d34355..be02057 100644
--- a/drivers/net/fsl-mc/dprc.c
+++ b/drivers/net/fsl-mc/dprc.c
@@ -1,8 +1,8 @@
 /*
  * Freescale Layerscape MC I/O wrapper
  *
- * Copyright (C) 2013-2015 Freescale Semiconductor, Inc.
- * Author: German Rivera <German.Rivera@freescale.com>
+ * Copyright (C) 2013-2016 Freescale Semiconductor, Inc.
+ * Copyright 2017 NXP
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -353,3 +353,26 @@ int dprc_get_connection(struct fsl_mc_io *mc_io,
 
 	return 0;
 }
+
+int dprc_get_api_version(struct fsl_mc_io *mc_io,
+			 u32 cmd_flags,
+			 u16 *major_ver,
+			 u16 *minor_ver)
+{
+	struct mc_command cmd = { 0 };
+	int err;
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPRC_CMDID_GET_API_VERSION,
+					  cmd_flags, 0);
+
+	/* send command to mc */
+	err = mc_send_command(mc_io, &cmd);
+	if (err)
+		return err;
+
+	/* retrieve response parameters */
+	mc_cmd_read_api_version(&cmd, major_ver, minor_ver);
+
+	return 0;
+}
diff --git a/drivers/net/fsl-mc/fsl_dpmng_cmd.h b/drivers/net/fsl-mc/fsl_dpmng_cmd.h
index 33f84f3..a91da2b 100644
--- a/drivers/net/fsl-mc/fsl_dpmng_cmd.h
+++ b/drivers/net/fsl-mc/fsl_dpmng_cmd.h
@@ -1,4 +1,5 @@
-/* Copyright 2013-2015 Freescale Semiconductor Inc.
+/* Copyright 2013-2016 Freescale Semiconductor Inc.
+ * Copyright 2017 NXP
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -6,7 +7,7 @@
 #define __FSL_DPMNG_CMD_H
 
 /* Command IDs */
-#define DPMNG_CMDID_GET_VERSION			0x831
+#define DPMNG_CMDID_GET_VERSION			0x8311
 
 /*                cmd, param, offset, width, type, arg_name */
 #define DPMNG_RSP_GET_VERSION(cmd, mc_ver_info) \
diff --git a/drivers/net/fsl-mc/mc.c b/drivers/net/fsl-mc/mc.c
index c76f582..bf9949b 100644
--- a/drivers/net/fsl-mc/mc.c
+++ b/drivers/net/fsl-mc/mc.c
@@ -854,21 +854,25 @@ int fsl_mc_ldpaa_init(bd_t *bis)
 
 static int dprc_version_check(struct fsl_mc_io *mc_io, uint16_t handle)
 {
-	struct dprc_attributes attr;
 	int error;
+	uint16_t major_ver, minor_ver;
 
-	memset(&attr, 0, sizeof(struct dprc_attributes));
-	error = dprc_get_attributes(mc_io, MC_CMD_NO_FLAGS, handle, &attr);
-	if (error == 0) {
-		if ((attr.version.major != DPRC_VER_MAJOR) ||
-		    (attr.version.minor != DPRC_VER_MINOR)) {
-			printf("DPRC version mismatch found %u.%u,",
-			       attr.version.major,
-			       attr.version.minor);
-			printf("supported version is %u.%u\n",
-			       DPRC_VER_MAJOR, DPRC_VER_MINOR);
-		}
+	error = dprc_get_api_version(mc_io, 0,
+				     &major_ver,
+				     &minor_ver);
+	if (error < 0) {
+		printf("dprc_get_api_version() failed: %d\n", error);
+		return error;
+	}
+
+	if (major_ver < DPRC_VER_MAJOR || (major_ver == DPRC_VER_MAJOR &&
+					   minor_ver < DPRC_VER_MINOR)) {
+		printf("DPRC version mismatch found %u.%u,",
+		       major_ver, minor_ver);
+		printf("supported version is %u.%u\n",
+		       DPRC_VER_MAJOR, DPRC_VER_MINOR);
 	}
+
 	return error;
 }
 
@@ -878,6 +882,7 @@ static int dpio_init(void)
 	struct dpio_attr attr;
 	struct dpio_cfg dpio_cfg;
 	int err = 0;
+	uint16_t major_ver, minor_ver;
 
 	dflt_dpio = (struct fsl_dpio_obj *)calloc(
 					sizeof(struct fsl_dpio_obj), 1);
@@ -886,18 +891,44 @@ static int dpio_init(void)
 		err = -ENOMEM;
 		goto err_calloc;
 	}
-
 	dpio_cfg.channel_mode = DPIO_LOCAL_CHANNEL;
 	dpio_cfg.num_priorities = 8;
 
-	err = dpio_create(dflt_mc_io, MC_CMD_NO_FLAGS, &dpio_cfg,
-			  &dflt_dpio->dpio_handle);
+	err = dpio_create(dflt_mc_io,
+			  dflt_dprc_handle,
+			  MC_CMD_NO_FLAGS,
+			  &dpio_cfg,
+			  &dflt_dpio->dpio_id);
 	if (err < 0) {
 		printf("dpio_create() failed: %d\n", err);
 		err = -ENODEV;
 		goto err_create;
 	}
 
+	err = dpio_get_api_version(dflt_mc_io, 0,
+				   &major_ver,
+				   &minor_ver);
+	if (err < 0) {
+		printf("dpio_get_api_version() failed: %d\n", err);
+		goto err_get_api_ver;
+	}
+
+	if (major_ver < DPIO_VER_MAJOR || (major_ver == DPIO_VER_MAJOR &&
+					   minor_ver < DPIO_VER_MINOR)) {
+		printf("DPRC version mismatch found %u.%u,",
+		       major_ver,
+		       minor_ver);
+	}
+
+	err = dpio_open(dflt_mc_io,
+			MC_CMD_NO_FLAGS,
+			dflt_dpio->dpio_id,
+			&dflt_dpio->dpio_handle);
+	if (err) {
+		printf("dpio_open() failed\n");
+		goto err_open;
+	}
+
 	memset(&attr, 0, sizeof(struct dpio_attr));
 	err = dpio_get_attributes(dflt_mc_io, MC_CMD_NO_FLAGS,
 				  dflt_dpio->dpio_handle, &attr);
@@ -906,15 +937,11 @@ static int dpio_init(void)
 		goto err_get_attr;
 	}
 
-	if ((attr.version.major != DPIO_VER_MAJOR) ||
-	    (attr.version.minor != DPIO_VER_MINOR)) {
-		printf("DPIO version mismatch found %u.%u,",
-		       attr.version.major, attr.version.minor);
-		printf("supported version is %u.%u\n",
-		       DPIO_VER_MAJOR, DPIO_VER_MINOR);
+	if (dflt_dpio->dpio_id != attr.id) {
+		printf("dnpi object id and attribute id are not same\n");
+		goto err_attr_not_same;
 	}
 
-	dflt_dpio->dpio_id = attr.id;
 #ifdef DEBUG
 	printf("Init: DPIO id=0x%d\n", dflt_dpio->dpio_id);
 #endif
@@ -945,8 +972,14 @@ err_get_swp_init:
 	dpio_disable(dflt_mc_io, MC_CMD_NO_FLAGS, dflt_dpio->dpio_handle);
 err_get_enable:
 err_get_attr:
+err_attr_not_same:
 	dpio_close(dflt_mc_io, MC_CMD_NO_FLAGS, dflt_dpio->dpio_handle);
-	dpio_destroy(dflt_mc_io, MC_CMD_NO_FLAGS, dflt_dpio->dpio_handle);
+err_open:
+err_get_api_ver:
+	dpio_destroy(dflt_mc_io,
+		     dflt_dprc_handle,
+		     MC_CMD_NO_FLAGS,
+		     dflt_dpio->dpio_id);
 err_create:
 	free(dflt_dpio);
 err_calloc:
@@ -963,7 +996,16 @@ static int dpio_exit(void)
 		goto err;
 	}
 
-	err = dpio_destroy(dflt_mc_io, MC_CMD_NO_FLAGS, dflt_dpio->dpio_handle);
+	dpio_close(dflt_mc_io, MC_CMD_NO_FLAGS, dflt_dpio->dpio_handle);
+	if (err < 0) {
+		printf("dpio_close() failed: %d\n", err);
+		goto err;
+	}
+
+	err = dpio_destroy(dflt_mc_io,
+			   dflt_dprc_handle,
+			   MC_CMD_NO_FLAGS,
+			   dflt_dpio->dpio_id);
 	if (err < 0) {
 		printf("dpio_destroy() failed: %d\n", err);
 		goto err;
@@ -1040,6 +1082,7 @@ static int dprc_init(void)
 
 	child_portal_id = MC_PORTAL_OFFSET_TO_PORTAL_ID(mc_portal_offset);
 	dflt_mc_io->mmio_regs = SOC_MC_PORTAL_ADDR(child_portal_id);
+
 #ifdef DEBUG
 	printf("MC portal of child DPRC container: %d, physical addr %p)\n",
 	       child_dprc_id, dflt_mc_io->mmio_regs);
@@ -1110,6 +1153,7 @@ static int dpbp_init(void)
 	int err;
 	struct dpbp_attr dpbp_attr;
 	struct dpbp_cfg dpbp_cfg;
+	uint16_t major_ver, minor_ver;
 
 	dflt_dpbp = (struct fsl_dpbp_obj *)calloc(
 					sizeof(struct fsl_dpbp_obj), 1);
@@ -1121,8 +1165,11 @@ static int dpbp_init(void)
 
 	dpbp_cfg.options = 512;
 
-	err = dpbp_create(dflt_mc_io, MC_CMD_NO_FLAGS, &dpbp_cfg,
-			  &dflt_dpbp->dpbp_handle);
+	err = dpbp_create(dflt_mc_io,
+			  dflt_dprc_handle,
+			  MC_CMD_NO_FLAGS,
+			  &dpbp_cfg,
+			  &dflt_dpbp->dpbp_id);
 
 	if (err < 0) {
 		err = -ENODEV;
@@ -1130,6 +1177,31 @@ static int dpbp_init(void)
 		goto err_create;
 	}
 
+	err = dpbp_get_api_version(dflt_mc_io, 0,
+				   &major_ver,
+				   &minor_ver);
+	if (err < 0) {
+		printf("dpbp_get_api_version() failed: %d\n", err);
+		goto err_get_api_ver;
+	}
+
+	if (major_ver < DPBP_VER_MAJOR || (major_ver == DPBP_VER_MAJOR &&
+					   minor_ver < DPBP_VER_MINOR)) {
+		printf("DPBP version mismatch found %u.%u,",
+		       major_ver, minor_ver);
+		printf("supported version is %u.%u\n",
+		       DPBP_VER_MAJOR, DPBP_VER_MINOR);
+	}
+
+	err = dpbp_open(dflt_mc_io,
+			MC_CMD_NO_FLAGS,
+			dflt_dpbp->dpbp_id,
+			&dflt_dpbp->dpbp_handle);
+	if (err) {
+		printf("dpbp_open() failed\n");
+		goto err_open;
+	}
+
 	memset(&dpbp_attr, 0, sizeof(struct dpbp_attr));
 	err = dpbp_get_attributes(dflt_mc_io, MC_CMD_NO_FLAGS,
 				  dflt_dpbp->dpbp_handle,
@@ -1139,17 +1211,13 @@ static int dpbp_init(void)
 		goto err_get_attr;
 	}
 
-	if ((dpbp_attr.version.major != DPBP_VER_MAJOR) ||
-	    (dpbp_attr.version.minor != DPBP_VER_MINOR)) {
-		printf("DPBP version mismatch found %u.%u,",
-		       dpbp_attr.version.major, dpbp_attr.version.minor);
-		printf("supported version is %u.%u\n",
-		       DPBP_VER_MAJOR, DPBP_VER_MINOR);
+	if (dflt_dpbp->dpbp_id != dpbp_attr.id) {
+		printf("dpbp object id and attribute id are not same\n");
+		goto err_attr_not_same;
 	}
 
-	dflt_dpbp->dpbp_attr.id = dpbp_attr.id;
 #ifdef DEBUG
-	printf("Init: DPBP id=0x%d\n", dflt_dpbp->dpbp_attr.id);
+	printf("Init: DPBP id=0x%x\n", dflt_dpbp->dpbp_attr.id);
 #endif
 
 	err = dpbp_close(dflt_mc_io, MC_CMD_NO_FLAGS, dflt_dpbp->dpbp_handle);
@@ -1160,12 +1228,18 @@ static int dpbp_init(void)
 
 	return 0;
 
-err_close:
-	free(dflt_dpbp);
 err_get_attr:
+err_attr_not_same:
 	dpbp_close(dflt_mc_io, MC_CMD_NO_FLAGS, dflt_dpbp->dpbp_handle);
-	dpbp_destroy(dflt_mc_io, MC_CMD_NO_FLAGS, dflt_dpbp->dpbp_handle);
+	dpbp_destroy(dflt_mc_io,
+		     dflt_dprc_handle,
+		     MC_CMD_NO_FLAGS,
+		     dflt_dpbp->dpbp_id);
+err_get_api_ver:
+err_close:
+err_open:
 err_create:
+	free(dflt_dpbp);
 err_calloc:
 	return err;
 }
@@ -1174,15 +1248,8 @@ static int dpbp_exit(void)
 {
 	int err;
 
-	err = dpbp_open(dflt_mc_io, MC_CMD_NO_FLAGS, dflt_dpbp->dpbp_attr.id,
-			&dflt_dpbp->dpbp_handle);
-	if (err < 0) {
-		printf("dpbp_open() failed: %d\n", err);
-		goto err;
-	}
-
-	err = dpbp_destroy(dflt_mc_io, MC_CMD_NO_FLAGS,
-			   dflt_dpbp->dpbp_handle);
+	err = dpbp_destroy(dflt_mc_io, dflt_dprc_handle, MC_CMD_NO_FLAGS,
+			   dflt_dpbp->dpbp_id);
 	if (err < 0) {
 		printf("dpbp_destroy() failed: %d\n", err);
 		goto err;
@@ -1203,10 +1270,9 @@ err:
 static int dpni_init(void)
 {
 	int err;
-	struct dpni_attr dpni_attr;
-	uint8_t	ext_cfg_buf[256] = {0};
-	struct dpni_extended_cfg dpni_extended_cfg;
+	uint8_t	cfg_buf[256] = {0};
 	struct dpni_cfg dpni_cfg;
+	uint16_t major_ver, minor_ver;
 
 	dflt_dpni = (struct fsl_dpni_obj *)calloc(
 					sizeof(struct fsl_dpni_obj), 1);
@@ -1216,50 +1282,53 @@ static int dpni_init(void)
 		goto err_calloc;
 	}
 
-	memset(&dpni_extended_cfg, 0, sizeof(dpni_extended_cfg));
-	err = dpni_prepare_extended_cfg(&dpni_extended_cfg, &ext_cfg_buf[0]);
+	memset(&dpni_cfg, 0, sizeof(dpni_cfg));
+	err = dpni_prepare_cfg(&dpni_cfg, &cfg_buf[0]);
 	if (err < 0) {
 		err = -ENODEV;
-		printf("dpni_prepare_extended_cfg() failed: %d\n", err);
-		goto err_prepare_extended_cfg;
+		printf("dpni_prepare_cfg() failed: %d\n", err);
+		goto err_prepare_cfg;
 	}
 
-	memset(&dpni_cfg, 0, sizeof(dpni_cfg));
-	dpni_cfg.adv.options = DPNI_OPT_UNICAST_FILTER |
-			       DPNI_OPT_MULTICAST_FILTER;
-
-	dpni_cfg.adv.ext_cfg_iova = (uint64_t)&ext_cfg_buf[0];
-	err = dpni_create(dflt_mc_io, MC_CMD_NO_FLAGS, &dpni_cfg,
-			  &dflt_dpni->dpni_handle);
-
+	err = dpni_create(dflt_mc_io,
+			  dflt_dprc_handle,
+			  MC_CMD_NO_FLAGS,
+			  &dpni_cfg,
+			  &dflt_dpni->dpni_id);
 	if (err < 0) {
 		err = -ENODEV;
-		printf("dpni_create() failed: %d\n", err);
+		printf("dpni create() failed: %d\n", err);
 		goto err_create;
 	}
 
-	memset(&dpni_attr, 0, sizeof(struct dpni_attr));
-	err = dpni_get_attributes(dflt_mc_io, MC_CMD_NO_FLAGS,
-				  dflt_dpni->dpni_handle,
-				  &dpni_attr);
+	err = dpni_get_api_version(dflt_mc_io, 0,
+				   &major_ver,
+				   &minor_ver);
 	if (err < 0) {
-		printf("dpni_get_attributes() failed: %d\n", err);
-		goto err_get_attr;
+		printf("dpni_get_api_version() failed: %d\n", err);
+		goto err_get_version;
 	}
 
-	if ((dpni_attr.version.major != DPNI_VER_MAJOR) ||
-	    (dpni_attr.version.minor != DPNI_VER_MINOR)) {
+	if (major_ver < DPNI_VER_MAJOR || (major_ver == DPNI_VER_MAJOR &&
+					   minor_ver < DPNI_VER_MINOR)) {
 		printf("DPNI version mismatch found %u.%u,",
-		       dpni_attr.version.major, dpni_attr.version.minor);
+		       major_ver, minor_ver);
 		printf("supported version is %u.%u\n",
 		       DPNI_VER_MAJOR, DPNI_VER_MINOR);
 	}
 
-	dflt_dpni->dpni_id = dpni_attr.id;
+	err = dpni_open(dflt_mc_io,
+			MC_CMD_NO_FLAGS,
+			dflt_dpni->dpni_id,
+			&dflt_dpni->dpni_handle);
+	if (err) {
+		printf("dpni_open() failed\n");
+		goto err_open;
+	}
+
 #ifdef DEBUG
 	printf("Init: DPNI id=0x%d\n", dflt_dpni->dpni_id);
 #endif
-
 	err = dpni_close(dflt_mc_io, MC_CMD_NO_FLAGS, dflt_dpni->dpni_handle);
 	if (err < 0) {
 		printf("dpni_close() failed: %d\n", err);
@@ -1269,11 +1338,15 @@ static int dpni_init(void)
 	return 0;
 
 err_close:
-err_get_attr:
 	dpni_close(dflt_mc_io, MC_CMD_NO_FLAGS, dflt_dpni->dpni_handle);
-	dpni_destroy(dflt_mc_io, MC_CMD_NO_FLAGS, dflt_dpni->dpni_handle);
+err_open:
+err_get_version:
+	dpni_destroy(dflt_mc_io,
+		     dflt_dprc_handle,
+		     MC_CMD_NO_FLAGS,
+		     dflt_dpni->dpni_id);
 err_create:
-err_prepare_extended_cfg:
+err_prepare_cfg:
 	free(dflt_dpni);
 err_calloc:
 	return err;
@@ -1283,15 +1356,8 @@ static int dpni_exit(void)
 {
 	int err;
 
-	err = dpni_open(dflt_mc_io, MC_CMD_NO_FLAGS, dflt_dpni->dpni_id,
-			&dflt_dpni->dpni_handle);
-	if (err < 0) {
-		printf("dpni_open() failed: %d\n", err);
-		goto err;
-	}
-
-	err = dpni_destroy(dflt_mc_io, MC_CMD_NO_FLAGS,
-			   dflt_dpni->dpni_handle);
+	err = dpni_destroy(dflt_mc_io, dflt_dprc_handle, MC_CMD_NO_FLAGS,
+			   dflt_dpni->dpni_id);
 	if (err < 0) {
 		printf("dpni_destroy() failed: %d\n", err);
 		goto err;
@@ -1420,6 +1486,7 @@ static int do_fsl_mc(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 #endif
 
 			sub_cmd = argv[2][0];
+
 			switch (sub_cmd) {
 			case 'm':
 				if (argc < 5)
diff --git a/drivers/net/ldpaa_eth/ldpaa_eth.c b/drivers/net/ldpaa_eth/ldpaa_eth.c
index 21be79a..109aba2 100644
--- a/drivers/net/ldpaa_eth/ldpaa_eth.c
+++ b/drivers/net/ldpaa_eth/ldpaa_eth.c
@@ -1,5 +1,6 @@
 /*
- * Copyright (C) 2014 Freescale Semiconductor
+ * Copyright (C) 2014-2016 Freescale Semiconductor
+ * Copyright 2017 NXP
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -42,80 +43,67 @@ static int init_phy(struct eth_device *dev)
 #endif
 
 #ifdef DEBUG
-static void ldpaa_eth_get_dpni_counter(void)
-{
-	int err = 0;
-	u64 value;
-
-	err = dpni_get_counter(dflt_mc_io, MC_CMD_NO_FLAGS,
-		     dflt_dpni->dpni_handle,
-		     DPNI_CNT_ING_FRAME,
-		     &value);
-	if (err < 0) {
-		printf("dpni_get_counter: DPNI_CNT_ING_FRAME failed\n");
-		return;
-	}
-	printf("DPNI_CNT_ING_FRAME=%lld\n", value);
 
-	err = dpni_get_counter(dflt_mc_io, MC_CMD_NO_FLAGS,
-		     dflt_dpni->dpni_handle,
-		     DPNI_CNT_ING_BYTE,
-		     &value);
-	if (err < 0) {
-		printf("dpni_get_counter: DPNI_CNT_ING_BYTE failed\n");
-		return;
-	}
-	printf("DPNI_CNT_ING_BYTE=%lld\n", value);
-
-	err = dpni_get_counter(dflt_mc_io, MC_CMD_NO_FLAGS,
-		     dflt_dpni->dpni_handle,
-		     DPNI_CNT_ING_FRAME_DROP ,
-		     &value);
-	if (err < 0) {
-		printf("dpni_get_counter: DPNI_CNT_ING_FRAME_DROP failed\n");
-		return;
-	}
-	printf("DPNI_CNT_ING_FRAME_DROP =%lld\n", value);
-
-	err = dpni_get_counter(dflt_mc_io, MC_CMD_NO_FLAGS,
-		     dflt_dpni->dpni_handle,
-		     DPNI_CNT_ING_FRAME_DISCARD,
-		     &value);
-	if (err < 0) {
-		printf("dpni_get_counter: DPNI_CNT_ING_FRAME_DISCARD failed\n");
-		return;
-	}
-	printf("DPNI_CNT_ING_FRAME_DISCARD=%lld\n", value);
-
-	err = dpni_get_counter(dflt_mc_io, MC_CMD_NO_FLAGS,
-		     dflt_dpni->dpni_handle,
-		     DPNI_CNT_EGR_FRAME,
-		     &value);
-	if (err < 0) {
-		printf("dpni_get_counter: DPNI_CNT_EGR_FRAME failed\n");
-		return;
-	}
-	printf("DPNI_CNT_EGR_FRAME=%lld\n", value);
+#define DPNI_STATS_PER_PAGE 6
+
+static const char *dpni_statistics[][DPNI_STATS_PER_PAGE] = {
+	{
+	"DPNI_CNT_ING_ALL_FRAMES",
+	"DPNI_CNT_ING_ALL_BYTES",
+	"DPNI_CNT_ING_MCAST_FRAMES",
+	"DPNI_CNT_ING_MCAST_BYTES",
+	"DPNI_CNT_ING_BCAST_FRAMES",
+	"DPNI_CNT_ING_BCAST_BYTES",
+	}, {
+	"DPNI_CNT_EGR_ALL_FRAMES",
+	"DPNI_CNT_EGR_ALL_BYTES",
+	"DPNI_CNT_EGR_MCAST_FRAMES",
+	"DPNI_CNT_EGR_MCAST_BYTES",
+	"DPNI_CNT_EGR_BCAST_FRAMES",
+	"DPNI_CNT_EGR_BCAST_BYTES",
+	}, {
+	"DPNI_CNT_ING_FILTERED_FRAMES",
+	"DPNI_CNT_ING_DISCARDED_FRAMES",
+	"DPNI_CNT_ING_NOBUFFER_DISCARDS",
+	"DPNI_CNT_EGR_DISCARDED_FRAMES",
+	"DPNI_CNT_EGR_CNF_FRAMES",
+	""
+	},
+};
+
+static void print_dpni_stats(const char *strings[],
+			     struct dpni_statistics dpni_stats)
+{
+	uint64_t *stat;
+	int i;
 
-	err = dpni_get_counter(dflt_mc_io, MC_CMD_NO_FLAGS,
-		     dflt_dpni->dpni_handle,
-		     DPNI_CNT_EGR_BYTE ,
-		     &value);
-	if (err < 0) {
-		printf("dpni_get_counter: DPNI_CNT_EGR_BYTE failed\n");
-		return;
+	stat = (uint64_t *)&dpni_stats;
+	for (i = 0; i < DPNI_STATS_PER_PAGE; i++) {
+		if (strcmp(strings[i], "\0") == 0)
+			break;
+		printf("%s= %llu\n", strings[i], *stat);
+		stat++;
 	}
-	printf("DPNI_CNT_EGR_BYTE =%lld\n", value);
+}
 
-	err = dpni_get_counter(dflt_mc_io, MC_CMD_NO_FLAGS,
-		     dflt_dpni->dpni_handle,
-		     DPNI_CNT_EGR_FRAME_DISCARD ,
-		     &value);
-	if (err < 0) {
-		printf("dpni_get_counter: DPNI_CNT_EGR_FRAME_DISCARD failed\n");
-		return;
+static void ldpaa_eth_get_dpni_counter(void)
+{
+	int err = 0;
+	unsigned int page = 0;
+	struct dpni_statistics dpni_stats;
+
+	printf("DPNI counters ..\n");
+	for (page = 0; page < 3; page++) {
+		err = dpni_get_statistics(dflt_mc_io, MC_CMD_NO_FLAGS,
+					  dflt_dpni->dpni_handle, page,
+					  &dpni_stats);
+		if (err < 0) {
+			printf("dpni_get_statistics: failed:");
+			printf("%d for page[%d]\n", err, page);
+			return;
+		}
+		print_dpni_stats(dpni_statistics[page], dpni_stats);
 	}
-	printf("DPNI_CNT_EGR_FRAME_DISCARD =%lld\n", value);
 }
 
 static void ldpaa_eth_get_dpmac_counter(struct eth_device *net_dev)
@@ -132,6 +120,7 @@ static void ldpaa_eth_get_dpmac_counter(struct eth_device *net_dev)
 		printf("dpmac_get_counter: DPMAC_CNT_ING_BYTE failed\n");
 		return;
 	}
+	printf("\nDPMAC counters ..\n");
 	printf("DPMAC_CNT_ING_BYTE=%lld\n", value);
 
 	err = dpmac_get_counter(dflt_mc_io, MC_CMD_NO_FLAGS,
@@ -392,7 +381,6 @@ error:
 static int ldpaa_eth_open(struct eth_device *net_dev, bd_t *bd)
 {
 	struct ldpaa_eth_priv *priv = (struct ldpaa_eth_priv *)net_dev->priv;
-	struct dpni_queue_attr rx_queue_attr;
 	struct dpmac_link_state	dpmac_link_state = { 0 };
 #ifdef DEBUG
 	struct dpni_link_state link_state;
@@ -400,6 +388,7 @@ static int ldpaa_eth_open(struct eth_device *net_dev, bd_t *bd)
 	int err = 0;
 	struct mii_dev *bus;
 	phy_interface_t enet_if;
+	struct dpni_queue d_queue;
 
 	if (net_dev->state == ETH_STATE_ACTIVE)
 		return 0;
@@ -508,6 +497,10 @@ static int ldpaa_eth_open(struct eth_device *net_dev, bd_t *bd)
 	}
 
 #ifdef DEBUG
+	printf("DPMAC link status: %d - ", dpmac_link_state.up);
+	dpmac_link_state.up == 0 ? printf("down\n") :
+	dpmac_link_state.up == 1 ? printf("up\n") : printf("error state\n");
+
 	err = dpni_get_link_state(dflt_mc_io, MC_CMD_NO_FLAGS,
 				  dflt_dpni->dpni_handle, &link_state);
 	if (err < 0) {
@@ -515,20 +508,21 @@ static int ldpaa_eth_open(struct eth_device *net_dev, bd_t *bd)
 		return err;
 	}
 
-	printf("link status: %d - ", link_state.up);
+	printf("DPNI link status: %d - ", link_state.up);
 	link_state.up == 0 ? printf("down\n") :
 	link_state.up == 1 ? printf("up\n") : printf("error state\n");
 #endif
 
-	/* TODO: support multiple Rx flows */
-	err = dpni_get_rx_flow(dflt_mc_io, MC_CMD_NO_FLAGS,
-			       dflt_dpni->dpni_handle, 0, 0, &rx_queue_attr);
+	memset(&d_queue, 0, sizeof(struct dpni_queue));
+	err = dpni_get_queue(dflt_mc_io, MC_CMD_NO_FLAGS,
+			     dflt_dpni->dpni_handle, DPNI_QUEUE_RX,
+			     0, 0, &d_queue);
 	if (err) {
-		printf("dpni_get_rx_flow() failed\n");
-		goto err_rx_flow;
+		printf("dpni_get_queue failed\n");
+		goto err_get_queue;
 	}
 
-	priv->rx_dflt_fqid = rx_queue_attr.fqid;
+	priv->rx_dflt_fqid = d_queue.fqid;
 
 	err = dpni_get_qdid(dflt_mc_io, MC_CMD_NO_FLAGS, dflt_dpni->dpni_handle,
 			    &priv->tx_qdid);
@@ -540,7 +534,7 @@ static int ldpaa_eth_open(struct eth_device *net_dev, bd_t *bd)
 	return priv->phydev->link;
 
 err_qdid:
-err_rx_flow:
+err_get_queue:
 	dpni_disable(dflt_mc_io, MC_CMD_NO_FLAGS, dflt_dpni->dpni_handle);
 err_dpni_bind:
 	ldpaa_dpbp_free();
@@ -548,7 +542,10 @@ err_dpbp_setup:
 	dpni_close(dflt_mc_io, MC_CMD_NO_FLAGS, dflt_dpni->dpni_handle);
 err_dpni_setup:
 err_dpamc_bind:
-	dpmac_destroy(dflt_mc_io, MC_CMD_NO_FLAGS, priv->dpmac_handle);
+	dpmac_close(dflt_mc_io, MC_CMD_NO_FLAGS, priv->dpmac_handle);
+	dpmac_destroy(dflt_mc_io,
+		      dflt_dprc_handle,
+		      MC_CMD_NO_FLAGS, priv->dpmac_id);
 err_dpmac_setup:
 	return err;
 }
@@ -575,7 +572,14 @@ static void ldpaa_eth_stop(struct eth_device *net_dev)
 	if (err < 0)
 		printf("dprc_disconnect() failed dpmac_endpoint\n");
 
-	err = dpmac_destroy(dflt_mc_io, MC_CMD_NO_FLAGS, priv->dpmac_handle);
+	err = dpmac_close(dflt_mc_io, MC_CMD_NO_FLAGS, priv->dpmac_handle);
+	if (err < 0)
+		printf("dpmac_close() failed\n");
+
+	err = dpmac_destroy(dflt_mc_io,
+			    dflt_dprc_handle,
+			    MC_CMD_NO_FLAGS,
+			    priv->dpmac_id);
 	if (err < 0)
 		printf("dpmac_destroy() failed\n");
 
@@ -593,9 +597,16 @@ static void ldpaa_eth_stop(struct eth_device *net_dev)
 	}
 #endif
 
+	/* Free DPBP handle and reset. */
 	ldpaa_dpbp_free();
+
 	dpni_reset(dflt_mc_io, MC_CMD_NO_FLAGS, dflt_dpni->dpni_handle);
+	if (err < 0)
+		printf("dpni_reset() failed\n");
+
 	dpni_close(dflt_mc_io, MC_CMD_NO_FLAGS, dflt_dpni->dpni_handle);
+	if (err < 0)
+		printf("dpni_close() failed\n");
 }
 
 static void ldpaa_dpbp_drain_cnt(int count)
@@ -711,6 +722,7 @@ static int ldpaa_dpbp_setup(void)
 	}
 
 	err = ldpaa_dpbp_seed(dflt_dpbp->dpbp_attr.bpid);
+
 	if (err) {
 		printf("Buffer seeding failed for DPBP %d (bpid=%d)\n",
 		       dflt_dpbp->dpbp_attr.id, dflt_dpbp->dpbp_attr.bpid);
@@ -739,21 +751,19 @@ static void ldpaa_dpbp_free(void)
 static int ldpaa_dpmac_version_check(struct fsl_mc_io *mc_io,
 				     struct ldpaa_eth_priv *priv)
 {
-	struct dpmac_attr attr;
 	int error;
-
-	memset(&attr, 0, sizeof(struct dpmac_attr));
-	error = dpmac_get_attributes(mc_io, MC_CMD_NO_FLAGS,
-				     priv->dpmac_handle,
-				     &attr);
-	if (error == 0) {
-		if ((attr.version.major != DPMAC_VER_MAJOR) ||
-		    (attr.version.minor != DPMAC_VER_MINOR)) {
-			printf("DPMAC version mismatch found %u.%u,",
-			       attr.version.major, attr.version.minor);
-			printf("supported version is %u.%u\n",
-			       DPMAC_VER_MAJOR, DPMAC_VER_MINOR);
-		}
+	uint16_t major_ver, minor_ver;
+
+	error = dpmac_get_api_version(dflt_mc_io, 0,
+					&major_ver,
+					&minor_ver);
+	if ((major_ver < DPMAC_VER_MAJOR) ||
+	    (major_ver == DPMAC_VER_MAJOR && minor_ver < DPMAC_VER_MINOR)) {
+		printf("DPMAC version mismatch found %u.%u,",
+		       major_ver, minor_ver);
+		printf("supported version is %u.%u\n",
+		       DPMAC_VER_MAJOR, DPMAC_VER_MINOR);
+		return error;
 	}
 
 	return error;
@@ -765,14 +775,36 @@ static int ldpaa_dpmac_setup(struct ldpaa_eth_priv *priv)
 	struct dpmac_cfg dpmac_cfg;
 
 	dpmac_cfg.mac_id = priv->dpmac_id;
-	err = dpmac_create(dflt_mc_io, MC_CMD_NO_FLAGS, &dpmac_cfg,
-			  &priv->dpmac_handle);
+
+	err = dpmac_create(dflt_mc_io,
+			   dflt_dprc_handle,
+			   MC_CMD_NO_FLAGS, &dpmac_cfg,
+			   &priv->dpmac_id);
 	if (err)
 		printf("dpmac_create() failed\n");
 
 	err = ldpaa_dpmac_version_check(dflt_mc_io, priv);
-	if (err < 0)
+	if (err < 0) {
 		printf("ldpaa_dpmac_version_check() failed: %d\n", err);
+		goto err_version_check;
+	}
+
+	err = dpmac_open(dflt_mc_io,
+			 MC_CMD_NO_FLAGS,
+			 priv->dpmac_id,
+			 &priv->dpmac_handle);
+	if (err < 0) {
+		printf("dpmac_open() failed: %d\n", err);
+		goto err_open;
+	}
+
+	return err;
+
+err_open:
+err_version_check:
+	dpmac_destroy(dflt_mc_io,
+		      dflt_dprc_handle,
+		      MC_CMD_NO_FLAGS, priv->dpmac_id);
 
 	return err;
 }
@@ -838,7 +870,6 @@ static int ldpaa_dpni_setup(struct ldpaa_eth_priv *priv)
 		printf("dpni_open() failed\n");
 		goto err_open;
 	}
-
 	err = dpni_get_attributes(dflt_mc_io, MC_CMD_NO_FLAGS,
 				  dflt_dpni->dpni_handle,
 				  &dflt_dpni->dpni_attrs);
@@ -857,12 +888,13 @@ static int ldpaa_dpni_setup(struct ldpaa_eth_priv *priv)
 	dflt_dpni->buf_layout.private_data_size = LDPAA_ETH_SWA_SIZE;
 	/* HW erratum mandates data alignment in multiples of 256 */
 	dflt_dpni->buf_layout.data_align = LDPAA_ETH_BUF_ALIGN;
+
 	/* ...rx, ... */
-	err = dpni_set_rx_buffer_layout(dflt_mc_io, MC_CMD_NO_FLAGS,
-					dflt_dpni->dpni_handle,
-					&dflt_dpni->buf_layout);
+	err = dpni_set_buffer_layout(dflt_mc_io, MC_CMD_NO_FLAGS,
+				     dflt_dpni->dpni_handle,
+				     &dflt_dpni->buf_layout, DPNI_QUEUE_RX);
 	if (err) {
-		printf("dpni_set_rx_buffer_layout() failed");
+		printf("dpni_set_buffer_layout() failed");
 		goto err_buf_layout;
 	}
 
@@ -870,21 +902,22 @@ static int ldpaa_dpni_setup(struct ldpaa_eth_priv *priv)
 	/* remove Rx-only options */
 	dflt_dpni->buf_layout.options &= ~(DPNI_BUF_LAYOUT_OPT_DATA_ALIGN |
 				      DPNI_BUF_LAYOUT_OPT_PARSER_RESULT);
-	err = dpni_set_tx_buffer_layout(dflt_mc_io, MC_CMD_NO_FLAGS,
-					dflt_dpni->dpni_handle,
-					&dflt_dpni->buf_layout);
+	err = dpni_set_buffer_layout(dflt_mc_io, MC_CMD_NO_FLAGS,
+				     dflt_dpni->dpni_handle,
+				     &dflt_dpni->buf_layout, DPNI_QUEUE_TX);
 	if (err) {
-		printf("dpni_set_tx_buffer_layout() failed");
+		printf("dpni_set_buffer_layout() failed");
 		goto err_buf_layout;
 	}
 
 	/* ... tx-confirm. */
 	dflt_dpni->buf_layout.options &= ~DPNI_BUF_LAYOUT_OPT_PRIVATE_DATA_SIZE;
-	err = dpni_set_tx_conf_buffer_layout(dflt_mc_io, MC_CMD_NO_FLAGS,
-					     dflt_dpni->dpni_handle,
-					     &dflt_dpni->buf_layout);
+	err = dpni_set_buffer_layout(dflt_mc_io, MC_CMD_NO_FLAGS,
+				     dflt_dpni->dpni_handle,
+				     &dflt_dpni->buf_layout,
+				     DPNI_QUEUE_TX_CONFIRM);
 	if (err) {
-		printf("dpni_set_tx_conf_buffer_layout() failed");
+		printf("dpni_set_buffer_layout() failed");
 		goto err_buf_layout;
 	}
 
@@ -919,8 +952,7 @@ err_open:
 static int ldpaa_dpni_bind(struct ldpaa_eth_priv *priv)
 {
 	struct dpni_pools_cfg pools_params;
-	struct dpni_tx_flow_cfg dflt_tx_flow;
-	struct dpni_tx_conf_cfg tx_conf_cfg;
+	struct dpni_queue tx_queue;
 	int err = 0;
 
 	memset(&pools_params, 0, sizeof(pools_params));
@@ -934,26 +966,22 @@ static int ldpaa_dpni_bind(struct ldpaa_eth_priv *priv)
 		return err;
 	}
 
-	priv->tx_flow_id = DPNI_NEW_FLOW_ID;
-	memset(&dflt_tx_flow, 0, sizeof(dflt_tx_flow));
+	memset(&tx_queue, 0, sizeof(struct dpni_queue));
+
+	err = dpni_set_queue(dflt_mc_io, MC_CMD_NO_FLAGS,
+			     dflt_dpni->dpni_handle,
+			     DPNI_QUEUE_TX, 0, 0, &tx_queue);
 
-	dflt_tx_flow.use_common_tx_conf_queue = 0;
-	err = dpni_set_tx_flow(dflt_mc_io, MC_CMD_NO_FLAGS,
-			       dflt_dpni->dpni_handle, &priv->tx_flow_id,
-			       &dflt_tx_flow);
 	if (err) {
-		printf("dpni_set_tx_flow() failed\n");
+		printf("dpni_set_queue() failed\n");
 		return err;
 	}
 
-	memset(&tx_conf_cfg, 0, sizeof(struct dpni_tx_conf_cfg));
-	tx_conf_cfg.errors_only = true;
-	/*Set tx-conf and error configuration*/
-	err = dpni_set_tx_conf(dflt_mc_io, MC_CMD_NO_FLAGS,
-			       dflt_dpni->dpni_handle,
-			       priv->tx_flow_id, &tx_conf_cfg);
+	err = dpni_set_tx_confirmation_mode(dflt_mc_io, MC_CMD_NO_FLAGS,
+					    dflt_dpni->dpni_handle,
+					    DPNI_CONF_DISABLE);
 	if (err) {
-		printf("dpni_set_tx_conf() failed\n");
+		printf("dpni_set_tx_confirmation_mode() failed\n");
 		return err;
 	}
 
@@ -996,7 +1024,6 @@ int ldpaa_eth_init(int dpmac_id, phy_interface_t enet_if)
 	struct ldpaa_eth_priv		*priv = NULL;
 	int				err = 0;
 
-
 	/* Net device */
 	net_dev = (struct eth_device *)malloc(sizeof(struct eth_device));
 	if (!net_dev) {
diff --git a/drivers/net/ldpaa_eth/ldpaa_eth.h b/drivers/net/ldpaa_eth/ldpaa_eth.h
index 3b16150..1e26630 100644
--- a/drivers/net/ldpaa_eth/ldpaa_eth.h
+++ b/drivers/net/ldpaa_eth/ldpaa_eth.h
@@ -1,5 +1,6 @@
 /*
- * Copyright (C) 2014 Freescale Semiconductor
+ * Copyright (C) 2014-2016 Freescale Semiconductor
+ * Copyright 2017 NXP
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -117,7 +118,7 @@ struct ldpaa_fas {
 
 struct ldpaa_eth_priv {
 	struct eth_device *net_dev;
-	int dpmac_id;
+	uint32_t dpmac_id;
 	uint16_t dpmac_handle;
 
 	uint16_t tx_data_offset;
diff --git a/include/fsl-mc/fsl_dpbp.h b/include/fsl-mc/fsl_dpbp.h
index b1ad46e..5401e86 100644
--- a/include/fsl-mc/fsl_dpbp.h
+++ b/include/fsl-mc/fsl_dpbp.h
@@ -1,8 +1,8 @@
 /*
  * Freescale Layerscape MC I/O wrapper
  *
- * Copyright (C) 2013-2015 Freescale Semiconductor, Inc.
- * Author: German Rivera <German.Rivera@freescale.com>
+ * Copyright (C) 2013-2016 Freescale Semiconductor, Inc.
+ * Copyright 2017 NXP
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -14,19 +14,21 @@
 #define __FSL_DPBP_H
 
 /* DPBP Version */
-#define DPBP_VER_MAJOR				2
-#define DPBP_VER_MINOR				2
+#define DPBP_VER_MAJOR				3
+#define DPBP_VER_MINOR				3
 
 /* Command IDs */
-#define DPBP_CMDID_CLOSE				0x800
-#define DPBP_CMDID_OPEN					0x804
-#define DPBP_CMDID_CREATE				0x904
-#define DPBP_CMDID_DESTROY				0x900
-
-#define DPBP_CMDID_ENABLE				0x002
-#define DPBP_CMDID_DISABLE				0x003
-#define DPBP_CMDID_GET_ATTR				0x004
-#define DPBP_CMDID_RESET				0x005
+#define DPBP_CMDID_CLOSE				0x8001
+#define DPBP_CMDID_OPEN					0x8041
+#define DPBP_CMDID_CREATE				0x9041
+#define DPBP_CMDID_DESTROY				0x9841
+#define DPBP_CMDID_GET_API_VERSION			0xa041
+
+#define DPBP_CMDID_ENABLE				0x0021
+#define DPBP_CMDID_DISABLE				0x0031
+#define DPBP_CMDID_GET_ATTR				0x0041
+#define DPBP_CMDID_RESET				0x0051
+#define DPBP_CMDID_IS_ENABLED				0x0061
 
 /*                cmd, param, offset, width, type, arg_name */
 #define DPBP_CMD_OPEN(cmd, dpbp_id) \
@@ -37,8 +39,6 @@
 do { \
 	MC_RSP_OP(cmd, 0, 16, 16, uint16_t, attr->bpid); \
 	MC_RSP_OP(cmd, 0, 32, 32, int,	    attr->id);\
-	MC_RSP_OP(cmd, 1, 0,  16, uint16_t, attr->version.major);\
-	MC_RSP_OP(cmd, 1, 16, 16, uint16_t, attr->version.minor);\
 } while (0)
 
 /* Data Path Buffer Pool API
@@ -114,9 +114,10 @@ struct dpbp_cfg {
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpbp_create(struct fsl_mc_io	*mc_io,
+		uint16_t		dprc_token,
 		uint32_t		cmd_flags,
 		const struct dpbp_cfg	*cfg,
-		uint16_t		*token);
+		uint32_t		*obj_id);
 
 /**
  * dpbp_destroy() - Destroy the DPBP object and release all its resources.
@@ -127,8 +128,9 @@ int dpbp_create(struct fsl_mc_io	*mc_io,
  * Return:	'0' on Success; error code otherwise.
  */
 int dpbp_destroy(struct fsl_mc_io	*mc_io,
+		 uint16_t		dprc_token,
 		 uint32_t		cmd_flags,
-		 uint16_t		token);
+		 uint32_t		obj_id);
 
 /**
  * dpbp_enable() - Enable the DPBP.
@@ -189,16 +191,7 @@ int dpbp_reset(struct fsl_mc_io	*mc_io,
  *		acquire/release operations on buffers
  */
 struct dpbp_attr {
-	int id;
-	/**
-	 * struct version - Structure representing DPBP version
-	 * @major:	DPBP major version
-	 * @minor:	DPBP minor version
-	 */
-	struct {
-		uint16_t major;
-		uint16_t minor;
-	} version;
+	uint32_t id;
 	uint16_t bpid;
 };
 
@@ -217,6 +210,21 @@ int dpbp_get_attributes(struct fsl_mc_io	*mc_io,
 			uint16_t		token,
 			struct dpbp_attr	*attr);
 
+/**
+ * dpbp_get_api_version - Retrieve DPBP Major and Minor version info.
+ *
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
+ * @major_ver:	DPBP major version
+ * @minor_ver:	DPBP minor version
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpbp_get_api_version(struct fsl_mc_io *mc_io,
+			 u32 cmd_flags,
+			 u16 *major_ver,
+			 u16 *minor_ver);
+
 /** @} */
 
 #endif /* __FSL_DPBP_H */
diff --git a/include/fsl-mc/fsl_dpio.h b/include/fsl-mc/fsl_dpio.h
index d8c458f..86251e2 100644
--- a/include/fsl-mc/fsl_dpio.h
+++ b/include/fsl-mc/fsl_dpio.h
@@ -1,5 +1,6 @@
 /*
- * Copyright (C) 2013-2015 Freescale Semiconductor
+ * Copyright (C) 2013-2016 Freescale Semiconductor
+ * Copyright 2017 NXP
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -8,19 +9,20 @@
 #define _FSL_DPIO_H
 
 /* DPIO Version */
-#define DPIO_VER_MAJOR				3
+#define DPIO_VER_MAJOR				4
 #define DPIO_VER_MINOR				2
 
 /* Command IDs */
-#define DPIO_CMDID_CLOSE					0x800
-#define DPIO_CMDID_OPEN						0x803
-#define DPIO_CMDID_CREATE					0x903
-#define DPIO_CMDID_DESTROY					0x900
+#define DPIO_CMDID_CLOSE					0x8001
+#define DPIO_CMDID_OPEN						0x8031
+#define DPIO_CMDID_CREATE					0x9031
+#define DPIO_CMDID_DESTROY					0x9831
+#define DPIO_CMDID_GET_API_VERSION				0xa031
 
-#define DPIO_CMDID_ENABLE					0x002
-#define DPIO_CMDID_DISABLE					0x003
-#define DPIO_CMDID_GET_ATTR					0x004
-#define DPIO_CMDID_RESET					0x005
+#define DPIO_CMDID_ENABLE					0x0021
+#define DPIO_CMDID_DISABLE					0x0031
+#define DPIO_CMDID_GET_ATTR					0x0041
+#define DPIO_CMDID_RESET					0x0051
 
 /*                cmd, param, offset, width, type, arg_name */
 #define DPIO_CMD_OPEN(cmd, dpio_id) \
@@ -43,8 +45,6 @@ do { \
 	MC_RSP_OP(cmd, 0, 56, 4,  enum dpio_channel_mode, attr->channel_mode);\
 	MC_RSP_OP(cmd, 1, 0,  64, uint64_t, attr->qbman_portal_ce_offset);\
 	MC_RSP_OP(cmd, 2, 0,  64, uint64_t, attr->qbman_portal_ci_offset);\
-	MC_RSP_OP(cmd, 3, 0,  16, uint16_t, attr->version.major);\
-	MC_RSP_OP(cmd, 3, 16, 16, uint16_t, attr->version.minor);\
 	MC_RSP_OP(cmd, 3, 32, 32, uint32_t, attr->qbman_version);\
 } while (0)
 
@@ -73,7 +73,7 @@ struct fsl_mc_io;
  */
 int dpio_open(struct fsl_mc_io	*mc_io,
 	      uint32_t		cmd_flags,
-	      int		dpio_id,
+	      uint32_t		dpio_id,
 	      uint16_t		*token);
 
 /**
@@ -114,9 +114,10 @@ struct dpio_cfg {
 /**
  * dpio_create() - Create the DPIO object.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @token:	Authentication token.
  * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @cfg:	Configuration structure
- * @token:	Returned token; use in subsequent API calls
+ * @obj_id:	Returned obj_id; use in subsequent API calls
  *
  * Create the DPIO object, allocate required resources and
  * perform required initialization.
@@ -134,21 +135,24 @@ struct dpio_cfg {
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpio_create(struct fsl_mc_io	*mc_io,
+		uint16_t		token,
 		uint32_t		cmd_flags,
 		const struct dpio_cfg	*cfg,
-		uint16_t		*token);
+		uint32_t		*obj_id);
 
 /**
  * dpio_destroy() - Destroy the DPIO object and release all its resources.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @token:	Authentication token.
  * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
- * @token:	Token of DPIO object
+ * @obj_id:	Object ID of DPIO
  *
  * Return:	'0' on Success; Error code otherwise
  */
 int dpio_destroy(struct fsl_mc_io	*mc_io,
+		 uint16_t		token,
 		 uint32_t		cmd_flags,
-		 uint16_t		token);
+		 uint32_t		obj_id);
 
 /**
  * dpio_enable() - Enable the DPIO, allow I/O portal operations.
@@ -199,16 +203,7 @@ int dpio_reset(struct fsl_mc_io	*mc_io,
  * @qbman_version: QBMAN version
  */
 struct dpio_attr {
-	int id;
-	/**
-	 * struct version - DPIO version
-	 * @major: DPIO major version
-	 * @minor: DPIO minor version
-	 */
-	struct {
-		uint16_t major;
-		uint16_t minor;
-	} version;
+	uint32_t id;
 	uint64_t qbman_portal_ce_offset;
 	uint64_t qbman_portal_ci_offset;
 	uint16_t qbman_portal_id;
@@ -231,4 +226,19 @@ int dpio_get_attributes(struct fsl_mc_io	*mc_io,
 			uint16_t		token,
 			struct dpio_attr	*attr);
 
+/**
+ * dpio_get_api_version - Retrieve DPIO Major and Minor version info.
+ *
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
+ * @major_ver:	DPIO major version
+ * @minor_ver:	DPIO minor version
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpio_get_api_version(struct fsl_mc_io *mc_io,
+			 u32 cmd_flags,
+			 u16 *major_ver,
+			 u16 *minor_ver);
+
 #endif /* _FSL_DPIO_H */
diff --git a/include/fsl-mc/fsl_dpmac.h b/include/fsl-mc/fsl_dpmac.h
index 296f3ae..36a5cca 100644
--- a/include/fsl-mc/fsl_dpmac.h
+++ b/include/fsl-mc/fsl_dpmac.h
@@ -1,7 +1,8 @@
 /*
  * Freescale Layerscape MC I/O wrapper
  *
- * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
+ * Copyright 2017 NXP
  * Author: Prabhakar Kushwaha <prabhakar@freescale.com>
  *
  * SPDX-License-Identifier:	GPL-2.0+
@@ -11,27 +12,28 @@
 #define __FSL_DPMAC_H
 
 /* DPMAC Version */
-#define DPMAC_VER_MAJOR				3
+#define DPMAC_VER_MAJOR				4
 #define DPMAC_VER_MINOR				2
 
 /* Command IDs */
-#define DPMAC_CMDID_CLOSE			0x800
-#define DPMAC_CMDID_OPEN			0x80c
-#define DPMAC_CMDID_CREATE			0x90c
-#define DPMAC_CMDID_DESTROY			0x900
+#define DPMAC_CMDID_CLOSE			0x8001
+#define DPMAC_CMDID_OPEN			0x80c1
+#define DPMAC_CMDID_CREATE			0x90c1
+#define DPMAC_CMDID_DESTROY			0x98c1
+#define DPMAC_CMDID_GET_API_VERSION             0xa0c1
 
-#define DPMAC_CMDID_GET_ATTR			0x004
-#define DPMAC_CMDID_RESET			0x005
+#define DPMAC_CMDID_GET_ATTR			0x0041
+#define DPMAC_CMDID_RESET			0x0051
 
-#define DPMAC_CMDID_MDIO_READ			0x0c0
-#define DPMAC_CMDID_MDIO_WRITE			0x0c1
-#define DPMAC_CMDID_GET_LINK_CFG		0x0c2
-#define DPMAC_CMDID_SET_LINK_STATE		0x0c3
-#define DPMAC_CMDID_GET_COUNTER			0x0c4
+#define DPMAC_CMDID_MDIO_READ			0x0c01
+#define DPMAC_CMDID_MDIO_WRITE			0x0c11
+#define DPMAC_CMDID_GET_LINK_CFG		0x0c21
+#define DPMAC_CMDID_SET_LINK_STATE		0x0c31
+#define DPMAC_CMDID_GET_COUNTER			0x0c41
 
 /*                cmd, param, offset, width, type, arg_name */
 #define DPMAC_CMD_CREATE(cmd, cfg) \
-	MC_CMD_OP(cmd, 0, 0,  32, int,      cfg->mac_id)
+	MC_CMD_OP(cmd, 0, 0,  16, uint16_t,      cfg->mac_id)
 
 /*                cmd, param, offset, width, type, arg_name */
 #define DPMAC_CMD_OPEN(cmd, dpmac_id) \
@@ -42,8 +44,6 @@
 do { \
 	MC_RSP_OP(cmd, 0, 0,  32, int,			attr->phy_id);\
 	MC_RSP_OP(cmd, 0, 32, 32, int,			attr->id);\
-	MC_RSP_OP(cmd, 1, 0,  16, uint16_t,		attr->version.major);\
-	MC_RSP_OP(cmd, 1, 16, 16, uint16_t,		attr->version.minor);\
 	MC_RSP_OP(cmd, 1, 32,  8, enum dpmac_link_type,	attr->link_type);\
 	MC_RSP_OP(cmd, 1, 40,  8, enum dpmac_eth_if,	attr->eth_if);\
 	MC_RSP_OP(cmd, 2, 0,  32, uint32_t,		attr->max_rate);\
@@ -85,7 +85,7 @@ do { \
 
 /*                cmd, param, offset, width, type, arg_name */
 #define DPMAC_CMD_GET_COUNTER(cmd, type) \
-	MC_CMD_OP(cmd, 0, 0,  8, enum dpmac_counter, type)
+	MC_CMD_OP(cmd, 1, 0,  64, enum dpmac_counter, type)
 
 /*                cmd, param, offset, width, type, arg_name */
 #define DPMAC_RSP_GET_COUNTER(cmd, counter) \
@@ -187,9 +187,10 @@ struct dpmac_cfg {
 /**
  * dpmac_create() - Create the DPMAC object.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @token:	Authentication token.
  * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @cfg:	Configuration structure
- * @token:	Returned token; use in subsequent API calls
+ * @obj_id:	Returned obj_id; use in subsequent API calls
  *
  * Create the DPMAC object, allocate required resources and
  * perform required initialization.
@@ -206,21 +207,24 @@ struct dpmac_cfg {
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpmac_create(struct fsl_mc_io	*mc_io,
+		 uint16_t		token,
 		 uint32_t		cmd_flags,
 		 const struct dpmac_cfg	*cfg,
-		 uint16_t		*token);
+		 uint32_t		*obj_id);
 
 /**
  * dpmac_destroy() - Destroy the DPMAC object and release all its resources.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @token:	Authentication token.
  * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
- * @token:	Token of DPMAC object
+ * @obj_id:	DPMAC object id
  *
  * Return:	'0' on Success; error code otherwise.
  */
 int dpmac_destroy(struct fsl_mc_io	*mc_io,
+		  uint16_t		token,
 		  uint32_t		cmd_flags,
-		  uint16_t		token);
+		  uint32_t		obj_id);
 
 /* DPMAC IRQ Index and Events */
 
@@ -246,15 +250,6 @@ struct dpmac_attr {
 	enum dpmac_link_type	link_type;
 	enum dpmac_eth_if	eth_if;
 	uint32_t		max_rate;
-	/**
-	 * struct version - Structure representing DPMAC version
-	 * @major:	DPMAC major version
-	 * @minor:	DPMAC minor version
-	 */
-	struct {
-		uint16_t major;
-		uint16_t minor;
-	} version;
 };
 
 /**
@@ -464,5 +459,19 @@ int dpmac_get_counter(struct fsl_mc_io		*mc_io,
 		      uint16_t			token,
 		      enum dpmac_counter	 type,
 		      uint64_t			*counter);
+/**
+ * dpmac_get_api_version - Retrieve DPMAC Major and Minor version info.
+ *
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
+ * @major_ver:	DPMAC major version
+ * @minor_ver:	DPMAC minor version
+ *
+ * Return:     '0' on Success; Error code otherwise.
+ */
+int dpmac_get_api_version(struct fsl_mc_io *mc_io,
+			  uint32_t cmd_flags,
+			  uint16_t *major_ver,
+			  uint16_t *minor_ver);
 
 #endif /* __FSL_DPMAC_H */
diff --git a/include/fsl-mc/fsl_dpni.h b/include/fsl-mc/fsl_dpni.h
index f396dc3..5b80b6f 100644
--- a/include/fsl-mc/fsl_dpni.h
+++ b/include/fsl-mc/fsl_dpni.h
@@ -1,5 +1,6 @@
 /*
- * Copyright (C) 2013-2015 Freescale Semiconductor
+ * Copyright (C) 2013-2016 Freescale Semiconductor
+ * Copyright 2017 NXP
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -7,134 +8,80 @@
 #define _FSL_DPNI_H
 
 /* DPNI Version */
-#define DPNI_VER_MAJOR				6
-#define DPNI_VER_MINOR				0
+#define DPNI_VER_MAJOR				7
+#define DPNI_VER_MINOR				3
 
 /* Command IDs */
-#define DPNI_CMDID_OPEN				0x801
-#define DPNI_CMDID_CLOSE			0x800
-#define DPNI_CMDID_CREATE			0x901
-#define DPNI_CMDID_DESTROY			0x900
-
-#define DPNI_CMDID_ENABLE			0x002
-#define DPNI_CMDID_DISABLE			0x003
-#define DPNI_CMDID_GET_ATTR			0x004
-#define DPNI_CMDID_RESET			0x005
-
-#define DPNI_CMDID_SET_POOLS			0x200
-#define DPNI_CMDID_GET_RX_BUFFER_LAYOUT		0x201
-#define DPNI_CMDID_SET_RX_BUFFER_LAYOUT		0x202
-#define DPNI_CMDID_GET_TX_BUFFER_LAYOUT		0x203
-#define DPNI_CMDID_SET_TX_BUFFER_LAYOUT		0x204
-#define DPNI_CMDID_SET_TX_CONF_BUFFER_LAYOUT	0x205
-#define DPNI_CMDID_GET_TX_CONF_BUFFER_LAYOUT	0x206
-#define DPNI_CMDID_SET_ERRORS_BEHAVIOR		0x20B
-
-#define DPNI_CMDID_GET_QDID			0x210
-#define DPNI_CMDID_GET_TX_DATA_OFFSET		0x212
-#define DPNI_CMDID_GET_COUNTER			0x213
-#define DPNI_CMDID_SET_COUNTER			0x214
-#define DPNI_CMDID_GET_LINK_STATE		0x215
-#define DPNI_CMDID_SET_LINK_CFG		0x21A
-
-#define DPNI_CMDID_SET_PRIM_MAC			0x224
-#define DPNI_CMDID_GET_PRIM_MAC			0x225
-#define DPNI_CMDID_ADD_MAC_ADDR			0x226
-#define DPNI_CMDID_REMOVE_MAC_ADDR		0x227
-
-#define DPNI_CMDID_SET_TX_FLOW			0x236
-#define DPNI_CMDID_GET_TX_FLOW			0x237
-#define DPNI_CMDID_SET_RX_FLOW			0x238
-#define DPNI_CMDID_GET_RX_FLOW			0x239
-#define DPNI_CMDID_SET_TX_CONF						0x257
-#define DPNI_CMDID_GET_TX_CONF						0x258
+#define DPNI_CMDID_OPEN				0x8011
+#define DPNI_CMDID_CLOSE			0x8001
+#define DPNI_CMDID_CREATE			0x9011
+#define DPNI_CMDID_DESTROY			0x9811
+#define DPNI_CMDID_GET_API_VERSION              0xa011
+
+#define DPNI_CMDID_ENABLE			0x0021
+#define DPNI_CMDID_DISABLE			0x0031
+#define DPNI_CMDID_GET_ATTR			0x0041
+#define DPNI_CMDID_RESET			0x0051
+
+#define DPNI_CMDID_SET_POOLS			0x2002
+#define DPNI_CMDID_SET_BUFFER_LAYOUT		0x2651
+#define DPNI_CMDID_GET_BUFFER_LAYOUT		0x2641
+#define DPNI_CMDID_SET_ERRORS_BEHAVIOR		0x20B1
+
+#define DPNI_CMDID_GET_QDID			0x2101
+#define DPNI_CMDID_GET_TX_DATA_OFFSET		0x2121
+#define DPNI_CMDID_GET_LINK_STATE		0x2151
+#define DPNI_CMDID_SET_LINK_CFG			0x21A1
+
+#define DPNI_CMDID_SET_PRIM_MAC			0x2241
+#define DPNI_CMDID_GET_PRIM_MAC			0x2251
+#define DPNI_CMDID_ADD_MAC_ADDR			0x2261
+#define DPNI_CMDID_REMOVE_MAC_ADDR		0x2271
+
+#define DPNI_CMDID_GET_STATISTICS		0x25D1
+#define DPNI_CMDID_RESET_STATISTICS		0x25E1
+#define DPNI_CMDID_GET_QUEUE			0x25F1
+#define DPNI_CMDID_SET_QUEUE			0x2601
+#define DPNI_CMDID_SET_TX_CONFIRMATION_MODE	0x2661
 
 /*                cmd, param, offset, width, type, arg_name */
 #define DPNI_CMD_OPEN(cmd, dpni_id) \
 	MC_CMD_OP(cmd,	 0,	0,	32,	int,	dpni_id)
 
-#define DPNI_PREP_EXTENDED_CFG(ext, cfg) \
+/*                cmd, param, offset, width, type, arg_name */
+#define DPNI_PREP_CFG(param, cfg) \
 do { \
-	MC_PREP_OP(ext, 0, 0,   16, uint16_t, cfg->tc_cfg[0].max_dist); \
-	MC_PREP_OP(ext, 0, 16,  16, uint16_t, cfg->tc_cfg[0].max_fs_entries); \
-	MC_PREP_OP(ext, 0, 32,  16, uint16_t, cfg->tc_cfg[1].max_dist); \
-	MC_PREP_OP(ext, 0, 48,  16, uint16_t, cfg->tc_cfg[1].max_fs_entries); \
-	MC_PREP_OP(ext, 1, 0,   16, uint16_t, cfg->tc_cfg[2].max_dist); \
-	MC_PREP_OP(ext, 1, 16,  16, uint16_t, cfg->tc_cfg[2].max_fs_entries); \
-	MC_PREP_OP(ext, 1, 32,  16, uint16_t, cfg->tc_cfg[3].max_dist); \
-	MC_PREP_OP(ext, 1, 48,  16, uint16_t, cfg->tc_cfg[3].max_fs_entries); \
-	MC_PREP_OP(ext, 2, 0,   16, uint16_t, cfg->tc_cfg[4].max_dist); \
-	MC_PREP_OP(ext, 2, 16,  16, uint16_t, cfg->tc_cfg[4].max_fs_entries); \
-	MC_PREP_OP(ext, 2, 32,  16, uint16_t, cfg->tc_cfg[5].max_dist); \
-	MC_PREP_OP(ext, 2, 48,  16, uint16_t, cfg->tc_cfg[5].max_fs_entries); \
-	MC_PREP_OP(ext, 3, 0,   16, uint16_t, cfg->tc_cfg[6].max_dist); \
-	MC_PREP_OP(ext, 3, 16,  16, uint16_t, cfg->tc_cfg[6].max_fs_entries); \
-	MC_PREP_OP(ext, 3, 32,  16, uint16_t, cfg->tc_cfg[7].max_dist); \
-	MC_PREP_OP(ext, 3, 48,  16, uint16_t, cfg->tc_cfg[7].max_fs_entries); \
-	MC_PREP_OP(ext, 4, 0,   16, uint16_t, \
-		   cfg->ipr_cfg.max_open_frames_ipv4); \
-	MC_PREP_OP(ext, 4, 16,  16, uint16_t, \
-		   cfg->ipr_cfg.max_open_frames_ipv6); \
-	MC_PREP_OP(ext, 4, 32,  16, uint16_t, \
-		   cfg->ipr_cfg.max_reass_frm_size); \
-	MC_PREP_OP(ext, 5, 0,   16, uint16_t, \
-		   cfg->ipr_cfg.min_frag_size_ipv4); \
-	MC_PREP_OP(ext, 5, 16,  16, uint16_t, \
-		   cfg->ipr_cfg.min_frag_size_ipv6); \
+	MC_PREP_OP(param, 0, 0,   32, uint16_t, cfg->adv.options); \
+	MC_PREP_OP(param, 0, 32,   8, uint16_t, cfg->adv.num_queues); \
+	MC_PREP_OP(param, 0, 40,   8, uint16_t, cfg->adv.num_tcs); \
+	MC_PREP_OP(param, 0, 48,   8, uint16_t, cfg->adv.mac_entries); \
+	MC_PREP_OP(param, 1, 0,   8, uint16_t, cfg->adv.vlan_entries); \
+	MC_PREP_OP(param, 1, 16,   8, uint16_t, cfg->adv.qos_entries); \
+	MC_PREP_OP(param, 1, 32,   16, uint16_t, cfg->adv.fs_entries); \
 } while (0)
 
-#define DPNI_EXT_EXTENDED_CFG(ext, cfg) \
+/*                cmd, param, offset, width, type, arg_name */
+#define DPNI_EXT_CFG(param, cfg) \
 do { \
-	MC_EXT_OP(ext, 0, 0,   16, uint16_t, cfg->tc_cfg[0].max_dist); \
-	MC_EXT_OP(ext, 0, 16,  16, uint16_t, cfg->tc_cfg[0].max_fs_entries); \
-	MC_EXT_OP(ext, 0, 32,  16, uint16_t, cfg->tc_cfg[1].max_dist); \
-	MC_EXT_OP(ext, 0, 48,  16, uint16_t, cfg->tc_cfg[1].max_fs_entries); \
-	MC_EXT_OP(ext, 1, 0,   16, uint16_t, cfg->tc_cfg[2].max_dist); \
-	MC_EXT_OP(ext, 1, 16,  16, uint16_t, cfg->tc_cfg[2].max_fs_entries); \
-	MC_EXT_OP(ext, 1, 32,  16, uint16_t, cfg->tc_cfg[3].max_dist); \
-	MC_EXT_OP(ext, 1, 48,  16, uint16_t, cfg->tc_cfg[3].max_fs_entries); \
-	MC_EXT_OP(ext, 2, 0,   16, uint16_t, cfg->tc_cfg[4].max_dist); \
-	MC_EXT_OP(ext, 2, 16,  16, uint16_t, cfg->tc_cfg[4].max_fs_entries); \
-	MC_EXT_OP(ext, 2, 32,  16, uint16_t, cfg->tc_cfg[5].max_dist); \
-	MC_EXT_OP(ext, 2, 48,  16, uint16_t, cfg->tc_cfg[5].max_fs_entries); \
-	MC_EXT_OP(ext, 3, 0,   16, uint16_t, cfg->tc_cfg[6].max_dist); \
-	MC_EXT_OP(ext, 3, 16,  16, uint16_t, cfg->tc_cfg[6].max_fs_entries); \
-	MC_EXT_OP(ext, 3, 32,  16, uint16_t, cfg->tc_cfg[7].max_dist); \
-	MC_EXT_OP(ext, 3, 48,  16, uint16_t, cfg->tc_cfg[7].max_fs_entries); \
-	MC_EXT_OP(ext, 4, 0,   16, uint16_t, \
-		  cfg->ipr_cfg.max_open_frames_ipv4); \
-	MC_EXT_OP(ext, 4, 16,  16, uint16_t, \
-		  cfg->ipr_cfg.max_open_frames_ipv6); \
-	MC_EXT_OP(ext, 4, 32,  16, uint16_t, \
-		  cfg->ipr_cfg.max_reass_frm_size); \
-	MC_EXT_OP(ext, 5, 0,   16, uint16_t, \
-		  cfg->ipr_cfg.min_frag_size_ipv4); \
-	MC_EXT_OP(ext, 5, 16,  16, uint16_t, \
-		  cfg->ipr_cfg.min_frag_size_ipv6); \
+	MC_EXT_OP(param, 0, 0,   32, uint16_t, cfg->adv.options); \
+	MC_EXT_OP(param, 0, 32,   8, uint16_t, cfg->adv.num_queues); \
+	MC_EXT_OP(param, 0, 40,   8, uint16_t, cfg->adv.num_tcs); \
+	MC_EXT_OP(param, 0, 48,   8, uint16_t, cfg->adv.mac_entries); \
+	MC_EXT_OP(param, 1, 0,   8, uint16_t, cfg->adv.vlan_entries); \
+	MC_EXT_OP(param, 1, 16,   8, uint16_t, cfg->adv.qos_entries); \
+	MC_EXT_OP(param, 1, 32,   16, uint16_t, cfg->adv.fs_entries); \
 } while (0)
 
 /*                cmd, param, offset, width, type, arg_name */
 #define DPNI_CMD_CREATE(cmd, cfg) \
 do { \
-	MC_CMD_OP(cmd, 0, 0,	8,  uint8_t,  cfg->adv.max_tcs); \
-	MC_CMD_OP(cmd, 0, 8,	8,  uint8_t,  cfg->adv.max_senders); \
-	MC_CMD_OP(cmd, 0, 16,	8,  uint8_t,  cfg->mac_addr[5]); \
-	MC_CMD_OP(cmd, 0, 24,	8,  uint8_t,  cfg->mac_addr[4]); \
-	MC_CMD_OP(cmd, 0, 32,	8,  uint8_t,  cfg->mac_addr[3]); \
-	MC_CMD_OP(cmd, 0, 40,	8,  uint8_t,  cfg->mac_addr[2]); \
-	MC_CMD_OP(cmd, 0, 48,	8,  uint8_t,  cfg->mac_addr[1]); \
-	MC_CMD_OP(cmd, 0, 56,	8,  uint8_t,  cfg->mac_addr[0]); \
-	MC_CMD_OP(cmd, 1, 0,	32, uint32_t, cfg->adv.options); \
-	MC_CMD_OP(cmd, 2, 0,	8,  uint8_t,  cfg->adv.max_unicast_filters); \
-	MC_CMD_OP(cmd, 2, 8,	8,  uint8_t,  cfg->adv.max_multicast_filters); \
-	MC_CMD_OP(cmd, 2, 16,	8,  uint8_t,  cfg->adv.max_vlan_filters); \
-	MC_CMD_OP(cmd, 2, 24,	8,  uint8_t,  cfg->adv.max_qos_entries); \
-	MC_CMD_OP(cmd, 2, 32,	8,  uint8_t,  cfg->adv.max_qos_key_size); \
-	MC_CMD_OP(cmd, 2, 48,	8,  uint8_t,  cfg->adv.max_dist_key_size); \
-	MC_CMD_OP(cmd, 2, 56,	8,  enum net_prot, cfg->adv.start_hdr); \
-	MC_CMD_OP(cmd, 4, 48,	8,  uint8_t, cfg->adv.max_policers); \
-	MC_CMD_OP(cmd, 4, 56,	8,  uint8_t, cfg->adv.max_congestion_ctrl); \
-	MC_CMD_OP(cmd, 5, 0,	64, uint64_t, cfg->adv.ext_cfg_iova); \
+	MC_CMD_OP(cmd, 0, 0,	32,	uint32_t,  cfg->adv.options); \
+	MC_CMD_OP(cmd, 0, 32,	8,	uint8_t,   cfg->adv.num_queues); \
+	MC_CMD_OP(cmd, 0, 40,	8,	uint8_t,   cfg->adv.num_tcs); \
+	MC_CMD_OP(cmd, 0, 48,	8,	uint8_t,   cfg->adv.mac_entries); \
+	MC_CMD_OP(cmd, 1, 0,	8,	uint8_t,   cfg->adv.vlan_entries); \
+	MC_CMD_OP(cmd, 1, 16,	8,	uint8_t,   cfg->adv.qos_entries); \
+	MC_CMD_OP(cmd, 1, 32,	16,	uint8_t,   cfg->adv.fs_entries); \
 } while (0)
 
 /*                cmd, param, offset, width, type, arg_name */
@@ -168,27 +115,18 @@ do { \
 } while (0)
 
 /*                cmd, param, offset, width, type, arg_name */
-#define DPNI_CMD_GET_ATTR(cmd, attr) \
-	MC_CMD_OP(cmd, 6, 0,  64, uint64_t, attr->ext_cfg_iova)
-
-/*                cmd, param, offset, width, type, arg_name */
 #define DPNI_RSP_GET_ATTR(cmd, attr) \
 do { \
-	MC_RSP_OP(cmd, 0, 0,  32, int,	    attr->id);\
-	MC_RSP_OP(cmd, 0, 32, 8,  uint8_t,  attr->max_tcs); \
-	MC_RSP_OP(cmd, 0, 40, 8,  uint8_t,  attr->max_senders); \
-	MC_RSP_OP(cmd, 0, 48, 8,  enum net_prot, attr->start_hdr); \
-	MC_RSP_OP(cmd, 1, 0,  32, uint32_t, attr->options); \
-	MC_RSP_OP(cmd, 2, 0,  8,  uint8_t,  attr->max_unicast_filters); \
-	MC_RSP_OP(cmd, 2, 8,  8,  uint8_t,  attr->max_multicast_filters);\
-	MC_RSP_OP(cmd, 2, 16, 8,  uint8_t,  attr->max_vlan_filters); \
-	MC_RSP_OP(cmd, 2, 24, 8,  uint8_t,  attr->max_qos_entries); \
-	MC_RSP_OP(cmd, 2, 32, 8,  uint8_t,  attr->max_qos_key_size); \
-	MC_RSP_OP(cmd, 2, 40, 8,  uint8_t,  attr->max_dist_key_size); \
-	MC_RSP_OP(cmd, 4, 48, 8,  uint8_t, attr->max_policers); \
-	MC_RSP_OP(cmd, 4, 56, 8,  uint8_t, attr->max_congestion_ctrl); \
-	MC_RSP_OP(cmd, 5, 32, 16, uint16_t, attr->version.major);\
-	MC_RSP_OP(cmd, 5, 48, 16, uint16_t, attr->version.minor);\
+	MC_RSP_OP(cmd, 0, 0,  32, int,	    attr->options);\
+	MC_RSP_OP(cmd, 0, 32,  8,  uint8_t,  attr->max_num_queues); \
+	MC_RSP_OP(cmd, 0, 40,  8,  uint8_t,  attr->max_num_tcs); \
+	MC_RSP_OP(cmd, 0, 48,  8,  uint8_t,  attr->max_mac_entries); \
+	MC_RSP_OP(cmd, 1,  0,  8,  uint8_t,  attr->max_vlan_entries); \
+	MC_RSP_OP(cmd, 1, 16,  8,  uint8_t,  attr->max_qos_entries); \
+	MC_RSP_OP(cmd, 1, 32, 16,  uint16_t,  attr->max_fs_entries); \
+	MC_RSP_OP(cmd, 2,  0,  8,  uint8_t,  attr->max_qos_key_size); \
+	MC_RSP_OP(cmd, 2,  8,  8,  uint8_t,  attr->max_fs_key_size); \
+	MC_RSP_OP(cmd, 2, 16, 16,  uint16_t,  attr->wriop_version); \
 } while (0)
 
 /*                cmd, param, offset, width, type, arg_name */
@@ -200,78 +138,17 @@ do { \
 } while (0)
 
 /*                cmd, param, offset, width, type, arg_name */
-#define DPNI_RSP_GET_RX_BUFFER_LAYOUT(cmd, layout) \
-do { \
-	MC_RSP_OP(cmd, 0, 0,  16, uint16_t, layout->private_data_size); \
-	MC_RSP_OP(cmd, 0, 16, 16, uint16_t, layout->data_align); \
-	MC_RSP_OP(cmd, 1, 0,  1,  int,	    layout->pass_timestamp); \
-	MC_RSP_OP(cmd, 1, 1,  1,  int,	    layout->pass_parser_result); \
-	MC_RSP_OP(cmd, 1, 2,  1,  int,	    layout->pass_frame_status); \
-	MC_RSP_OP(cmd, 1, 16, 16, uint16_t, layout->data_head_room); \
-	MC_RSP_OP(cmd, 1, 32, 16, uint16_t, layout->data_tail_room); \
-} while (0)
-
-/*                cmd, param, offset, width, type, arg_name */
-#define DPNI_CMD_SET_RX_BUFFER_LAYOUT(cmd, layout) \
-do { \
-	MC_CMD_OP(cmd, 0, 0,  16, uint16_t, layout->private_data_size); \
-	MC_CMD_OP(cmd, 0, 16, 16, uint16_t, layout->data_align); \
-	MC_CMD_OP(cmd, 0, 32, 32, uint32_t, layout->options); \
-	MC_CMD_OP(cmd, 1, 0,  1,  int,	    layout->pass_timestamp); \
-	MC_CMD_OP(cmd, 1, 1,  1,  int,	    layout->pass_parser_result); \
-	MC_CMD_OP(cmd, 1, 2,  1,  int,	    layout->pass_frame_status); \
-	MC_CMD_OP(cmd, 1, 16, 16, uint16_t, layout->data_head_room); \
-	MC_CMD_OP(cmd, 1, 32, 16, uint16_t, layout->data_tail_room); \
-} while (0)
-
-/*                cmd, param, offset, width, type, arg_name */
-#define DPNI_RSP_GET_TX_BUFFER_LAYOUT(cmd, layout) \
-do { \
-	MC_RSP_OP(cmd, 0, 0,  16, uint16_t, layout->private_data_size); \
-	MC_RSP_OP(cmd, 0, 16, 16, uint16_t, layout->data_align); \
-	MC_RSP_OP(cmd, 1, 0,  1,  int,      layout->pass_timestamp); \
-	MC_RSP_OP(cmd, 1, 1,  1,  int,	    layout->pass_parser_result); \
-	MC_RSP_OP(cmd, 1, 2,  1,  int,	    layout->pass_frame_status); \
-	MC_RSP_OP(cmd, 1, 16, 16, uint16_t, layout->data_head_room); \
-	MC_RSP_OP(cmd, 1, 32, 16, uint16_t, layout->data_tail_room); \
-} while (0)
-
-/*                cmd, param, offset, width, type, arg_name */
-#define DPNI_CMD_SET_TX_BUFFER_LAYOUT(cmd, layout) \
-do { \
-	MC_CMD_OP(cmd, 0, 0,  16, uint16_t, layout->private_data_size); \
-	MC_CMD_OP(cmd, 0, 16, 16, uint16_t, layout->data_align); \
-	MC_CMD_OP(cmd, 0, 32, 32, uint32_t, layout->options); \
-	MC_CMD_OP(cmd, 1, 0,  1,  int,	    layout->pass_timestamp); \
-	MC_CMD_OP(cmd, 1, 1,  1,  int,	    layout->pass_parser_result); \
-	MC_CMD_OP(cmd, 1, 2,  1,  int,	    layout->pass_frame_status); \
-	MC_CMD_OP(cmd, 1, 16, 16, uint16_t, layout->data_head_room); \
-	MC_CMD_OP(cmd, 1, 32, 16, uint16_t, layout->data_tail_room); \
-} while (0)
-
-/*                cmd, param, offset, width, type, arg_name */
-#define DPNI_RSP_GET_TX_CONF_BUFFER_LAYOUT(cmd, layout) \
-do { \
-	MC_RSP_OP(cmd, 0, 0,  16, uint16_t, layout->private_data_size); \
-	MC_RSP_OP(cmd, 0, 16, 16, uint16_t, layout->data_align); \
-	MC_RSP_OP(cmd, 1, 0,  1,  int,      layout->pass_timestamp); \
-	MC_RSP_OP(cmd, 1, 1,  1,  int,	    layout->pass_parser_result); \
-	MC_RSP_OP(cmd, 1, 2,  1,  int,	    layout->pass_frame_status); \
-	MC_RSP_OP(cmd, 1, 16, 16, uint16_t, layout->data_head_room); \
-	MC_RSP_OP(cmd, 1, 32, 16, uint16_t, layout->data_tail_room); \
-} while (0)
-
-/*                cmd, param, offset, width, type, arg_name */
-#define DPNI_CMD_SET_TX_CONF_BUFFER_LAYOUT(cmd, layout) \
+#define DPNI_CMD_SET_BUFFER_LAYOUT(cmd, layout, queue) \
 do { \
-	MC_CMD_OP(cmd, 0, 0,  16, uint16_t, layout->private_data_size); \
-	MC_CMD_OP(cmd, 0, 16, 16, uint16_t, layout->data_align); \
-	MC_CMD_OP(cmd, 0, 32, 32, uint32_t, layout->options); \
-	MC_CMD_OP(cmd, 1, 0,  1,  int,	    layout->pass_timestamp); \
-	MC_CMD_OP(cmd, 1, 1,  1,  int,	    layout->pass_parser_result); \
-	MC_CMD_OP(cmd, 1, 2,  1,  int,	    layout->pass_frame_status); \
-	MC_CMD_OP(cmd, 1, 16, 16, uint16_t, layout->data_head_room); \
-	MC_CMD_OP(cmd, 1, 32, 16, uint16_t, layout->data_tail_room); \
+	MC_CMD_OP(cmd, 0, 0,  8, enum dpni_queue_type, queue); \
+	MC_CMD_OP(cmd, 1, 0,  16, uint16_t, layout->private_data_size); \
+	MC_CMD_OP(cmd, 1, 16, 16, uint16_t, layout->data_align); \
+	MC_CMD_OP(cmd, 0, 32, 16, uint16_t, layout->options); \
+	MC_CMD_OP(cmd, 0, 48,  1,  int,	    layout->pass_timestamp); \
+	MC_CMD_OP(cmd, 0, 49,  1,  int,	    layout->pass_parser_result); \
+	MC_CMD_OP(cmd, 0, 50,  1,  int,	    layout->pass_frame_status); \
+	MC_CMD_OP(cmd, 1, 32, 16, uint16_t, layout->data_head_room); \
+	MC_CMD_OP(cmd, 1, 48, 16, uint16_t, layout->data_tail_room); \
 } while (0)
 
 /*                cmd, param, offset, width, type, arg_name */
@@ -283,21 +160,6 @@ do { \
 	MC_RSP_OP(cmd, 0, 0,  16, uint16_t, data_offset)
 
 /*                cmd, param, offset, width, type, arg_name */
-#define DPNI_CMD_GET_COUNTER(cmd, counter) \
-	MC_CMD_OP(cmd, 0, 0,  16, enum dpni_counter, counter)
-
-/*                cmd, param, offset, width, type, arg_name */
-#define DPNI_RSP_GET_COUNTER(cmd, value) \
-	MC_RSP_OP(cmd, 1, 0,  64, uint64_t, value)
-
-/*                cmd, param, offset, width, type, arg_name */
-#define DPNI_CMD_SET_COUNTER(cmd, counter, value) \
-do { \
-	MC_CMD_OP(cmd, 0, 0,  16, enum dpni_counter, counter); \
-	MC_CMD_OP(cmd, 1, 0,  64, uint64_t, value); \
-} while (0)
-
-/*                cmd, param, offset, width, type, arg_name */
 #define DPNI_CMD_SET_LINK_CFG(cmd, cfg) \
 do { \
 	MC_CMD_OP(cmd, 1, 0,  32, uint32_t, cfg->rate);\
@@ -358,129 +220,54 @@ do { \
 	MC_CMD_OP(cmd, 0, 56, 8,  uint8_t,  mac_addr[0]); \
 } while (0)
 
-/*                cmd, param, offset, width, type, arg_name */
-#define DPNI_CMD_SET_TX_FLOW(cmd, flow_id, cfg) \
+#define DPNI_CMD_GET_QUEUE(cmd, type, tc, index) \
 do { \
-	MC_CMD_OP(cmd, 0, 43, 1,  int,	    cfg->l3_chksum_gen);\
-	MC_CMD_OP(cmd, 0, 44, 1,  int,	    cfg->l4_chksum_gen);\
-	MC_CMD_OP(cmd, 0, 45, 1,  int,	    cfg->use_common_tx_conf_queue);\
-	MC_CMD_OP(cmd, 0, 48, 16, uint16_t, flow_id);\
-	MC_CMD_OP(cmd, 2, 0,  32, uint32_t, cfg->options);\
+	MC_CMD_OP(cmd, 0,  0,  8, enum dpni_queue_type, type); \
+	MC_CMD_OP(cmd, 0,  8,  8, uint8_t, tc); \
+	MC_CMD_OP(cmd, 0, 16,  8, uint8_t, index); \
 } while (0)
 
-/*                cmd, param, offset, width, type, arg_name */
-#define DPNI_RSP_SET_TX_FLOW(cmd, flow_id) \
-	MC_RSP_OP(cmd, 0, 48, 16, uint16_t, flow_id)
-
-/*                cmd, param, offset, width, type, arg_name */
-#define DPNI_CMD_GET_TX_FLOW(cmd, flow_id) \
-	MC_CMD_OP(cmd, 0, 48, 16, uint16_t, flow_id)
-
-/*                cmd, param, offset, width, type, arg_name */
-#define DPNI_RSP_GET_TX_FLOW(cmd, attr) \
+#define DPNI_RSP_GET_QUEUE(cmd, queue) \
 do { \
-	MC_RSP_OP(cmd, 0, 43, 1,  int,	    attr->l3_chksum_gen);\
-	MC_RSP_OP(cmd, 0, 44, 1,  int,	    attr->l4_chksum_gen);\
-	MC_RSP_OP(cmd, 0, 45, 1,  int,	    attr->use_common_tx_conf_queue);\
+	MC_RSP_OP(cmd, 1,  0, 32, uint32_t, (queue)->destination.id); \
+	MC_RSP_OP(cmd, 1, 56,  4, enum dpni_dest, (queue)->destination.type); \
+	MC_RSP_OP(cmd, 1, 62,  1, char, (queue)->destination.stash_ctrl); \
+	MC_RSP_OP(cmd, 1, 63,  1, char, (queue)->destination.hold_active); \
+	MC_RSP_OP(cmd, 2,  0, 64, uint64_t, (queue)->flc); \
+	MC_RSP_OP(cmd, 3,  0, 64, uint64_t, (queue)->user_context); \
+	MC_RSP_OP(cmd, 4,  0, 32, uint32_t, (queue)->fqid); \
+	MC_RSP_OP(cmd, 4, 32, 16, uint16_t, (queue)->qdbin); \
 } while (0)
 
-/*                cmd, param, offset, width, type, arg_name */
-#define DPNI_CMD_SET_RX_FLOW(cmd, tc_id, flow_id, cfg) \
+#define DPNI_CMD_SET_QUEUE(cmd, type, tc, index, queue) \
 do { \
-	MC_CMD_OP(cmd, 0, 0,  32, int,      cfg->dest_cfg.dest_id); \
-	MC_CMD_OP(cmd, 0, 32, 8,  uint8_t,  cfg->dest_cfg.priority);\
-	MC_CMD_OP(cmd, 0, 40, 2,  enum dpni_dest, cfg->dest_cfg.dest_type);\
-	MC_CMD_OP(cmd, 0, 42, 1,  int,      cfg->order_preservation_en);\
-	MC_CMD_OP(cmd, 0, 48, 16, uint16_t, flow_id); \
-	MC_CMD_OP(cmd, 1, 0,  64, uint64_t, cfg->user_ctx); \
-	MC_CMD_OP(cmd, 2, 16, 8,  uint8_t,  tc_id); \
-	MC_CMD_OP(cmd, 2, 32, 32, uint32_t, cfg->options); \
-	MC_CMD_OP(cmd, 3, 0,  4,  enum dpni_flc_type, cfg->flc_cfg.flc_type); \
-	MC_CMD_OP(cmd, 3, 4,  4,  enum dpni_stash_size, \
-		cfg->flc_cfg.frame_data_size);\
-	MC_CMD_OP(cmd, 3, 8,  4,  enum dpni_stash_size, \
-		cfg->flc_cfg.flow_context_size);\
-	MC_CMD_OP(cmd, 3, 32, 32, uint32_t, cfg->flc_cfg.options);\
-	MC_CMD_OP(cmd, 4, 0,  64, uint64_t, cfg->flc_cfg.flow_context);\
-	MC_CMD_OP(cmd, 5, 0,  32, uint32_t, cfg->tail_drop_threshold); \
+	MC_CMD_OP(cmd, 0,  0,  8, enum dpni_queue_type, type); \
+	MC_CMD_OP(cmd, 0,  8,  8, uint8_t, tc); \
+	MC_CMD_OP(cmd, 0, 16,  8, uint8_t, index); \
+	MC_CMD_OP(cmd, 0, 24,  8, uint8_t, (queue)->options); \
+	MC_CMD_OP(cmd, 1,  0, 32, uint32_t, (queue)->destination.id); \
+	MC_CMD_OP(cmd, 1, 56,  4, enum dpni_dest, (queue)->destination.type); \
+	MC_CMD_OP(cmd, 1, 62,  1, char, (queue)->destination.stash_ctrl); \
+	MC_CMD_OP(cmd, 1, 63,  1, char, (queue)->destination.hold_active); \
+	MC_CMD_OP(cmd, 1,  0, 32, uint32_t, (queue)->destination.id); \
+	MC_CMD_OP(cmd, 2,  0, 64, uint64_t, (queue)->flc); \
+	MC_CMD_OP(cmd, 3,  0, 64, uint64_t, (queue)->user_context); \
 } while (0)
 
-/*                cmd, param, offset, width, type, arg_name */
-#define DPNI_CMD_GET_RX_FLOW(cmd, tc_id, flow_id) \
-do { \
-	MC_CMD_OP(cmd, 0, 16, 8,  uint8_t,  tc_id); \
-	MC_CMD_OP(cmd, 0, 48, 16, uint16_t, flow_id); \
-} while (0)
+/*			cmd, param, offset, width, type, arg_name */
+#define DPNI_CMD_GET_STATISTICS(cmd, page) \
+	MC_CMD_OP(cmd, 0, 0, 8, uint8_t, page)
 
 /*                cmd, param, offset, width, type, arg_name */
-#define DPNI_RSP_GET_RX_FLOW(cmd, attr) \
+#define DPNI_RSP_GET_STATISTICS(cmd, stat) \
 do { \
-	MC_RSP_OP(cmd, 0, 0,  32, int,      attr->dest_cfg.dest_id); \
-	MC_RSP_OP(cmd, 0, 32, 8,  uint8_t,  attr->dest_cfg.priority);\
-	MC_RSP_OP(cmd, 0, 40, 2,  enum dpni_dest, attr->dest_cfg.dest_type); \
-	MC_RSP_OP(cmd, 0, 42, 1,  int,      attr->order_preservation_en);\
-	MC_RSP_OP(cmd, 1, 0,  64, uint64_t, attr->user_ctx); \
-	MC_RSP_OP(cmd, 2, 0,  32, uint32_t, attr->tail_drop_threshold); \
-	MC_RSP_OP(cmd, 2, 32, 32, uint32_t, attr->fqid); \
-	MC_RSP_OP(cmd, 3, 0,  4,  enum dpni_flc_type, attr->flc_cfg.flc_type); \
-	MC_RSP_OP(cmd, 3, 4,  4,  enum dpni_stash_size, \
-		attr->flc_cfg.frame_data_size);\
-	MC_RSP_OP(cmd, 3, 8,  4,  enum dpni_stash_size, \
-		attr->flc_cfg.flow_context_size);\
-	MC_RSP_OP(cmd, 3, 32, 32, uint32_t, attr->flc_cfg.options);\
-	MC_RSP_OP(cmd, 4, 0,  64, uint64_t, attr->flc_cfg.flow_context);\
-} while (0)
-
-#define DPNI_CMD_SET_TX_CONF(cmd, flow_id, cfg) \
-do { \
-	MC_CMD_OP(cmd, 0, 32, 8,  uint8_t, cfg->queue_cfg.dest_cfg.priority); \
-	MC_CMD_OP(cmd, 0, 40, 2,  enum dpni_dest, \
-		cfg->queue_cfg.dest_cfg.dest_type); \
-	MC_CMD_OP(cmd, 0, 42, 1,  int, cfg->errors_only); \
-	MC_CMD_OP(cmd, 0, 46, 1,  int, cfg->queue_cfg.order_preservation_en); \
-	MC_CMD_OP(cmd, 0, 48, 16, uint16_t, flow_id); \
-	MC_CMD_OP(cmd, 1, 0,  64, uint64_t, cfg->queue_cfg.user_ctx); \
-	MC_CMD_OP(cmd, 2, 0,  32, uint32_t, cfg->queue_cfg.options); \
-	MC_CMD_OP(cmd, 2, 32, 32, int,	    cfg->queue_cfg.dest_cfg.dest_id); \
-	MC_CMD_OP(cmd, 3, 0,  32, uint32_t, \
-		cfg->queue_cfg.tail_drop_threshold); \
-	MC_CMD_OP(cmd, 4, 0,  4,  enum dpni_flc_type, \
-		cfg->queue_cfg.flc_cfg.flc_type); \
-	MC_CMD_OP(cmd, 4, 4,  4,  enum dpni_stash_size, \
-		cfg->queue_cfg.flc_cfg.frame_data_size); \
-	MC_CMD_OP(cmd, 4, 8,  4,  enum dpni_stash_size, \
-		cfg->queue_cfg.flc_cfg.flow_context_size); \
-	MC_CMD_OP(cmd, 4, 32, 32, uint32_t, cfg->queue_cfg.flc_cfg.options); \
-	MC_CMD_OP(cmd, 5, 0,  64, uint64_t, \
-		cfg->queue_cfg.flc_cfg.flow_context); \
-} while (0)
-
-#define DPNI_CMD_GET_TX_CONF(cmd, flow_id) \
-		MC_CMD_OP(cmd, 0, 48, 16, uint16_t,  flow_id)
-
-#define DPNI_RSP_GET_TX_CONF(cmd, attr) \
-do { \
-	MC_RSP_OP(cmd, 0, 32, 8,  uint8_t, \
-		  attr->queue_attr.dest_cfg.priority); \
-	MC_RSP_OP(cmd, 0, 40, 2,  enum dpni_dest, \
-		attr->queue_attr.dest_cfg.dest_type); \
-	MC_RSP_OP(cmd, 0, 42, 1,  int, attr->errors_only); \
-	MC_RSP_OP(cmd, 0, 46, 1,  int, \
-		  attr->queue_attr.order_preservation_en); \
-	MC_RSP_OP(cmd, 1, 0,  64, uint64_t, attr->queue_attr.user_ctx); \
-	MC_RSP_OP(cmd, 2, 32, 32, int,	attr->queue_attr.dest_cfg.dest_id); \
-	MC_RSP_OP(cmd, 3, 0,  32, uint32_t, \
-		attr->queue_attr.tail_drop_threshold); \
-	MC_RSP_OP(cmd, 3, 32, 32, uint32_t, attr->queue_attr.fqid); \
-	MC_RSP_OP(cmd, 4, 0,  4,  enum dpni_flc_type, \
-		attr->queue_attr.flc_cfg.flc_type); \
-	MC_RSP_OP(cmd, 4, 4,  4,  enum dpni_stash_size, \
-		attr->queue_attr.flc_cfg.frame_data_size); \
-	MC_RSP_OP(cmd, 4, 8,  4,  enum dpni_stash_size, \
-		attr->queue_attr.flc_cfg.flow_context_size); \
-	MC_RSP_OP(cmd, 4, 32, 32, uint32_t, attr->queue_attr.flc_cfg.options); \
-	MC_RSP_OP(cmd, 5, 0,  64, uint64_t, \
-		attr->queue_attr.flc_cfg.flow_context); \
+	MC_RSP_OP(cmd, 0, 0, 64, uint64_t, (stat)->counter0); \
+	MC_RSP_OP(cmd, 1, 0, 64, uint64_t, (stat)->counter1); \
+	MC_RSP_OP(cmd, 2, 0, 64, uint64_t, (stat)->counter2); \
+	MC_RSP_OP(cmd, 3, 0, 64, uint64_t, (stat)->counter3); \
+	MC_RSP_OP(cmd, 4, 0, 64, uint64_t, (stat)->counter4); \
+	MC_RSP_OP(cmd, 5, 0, 64, uint64_t, (stat)->counter5); \
+	MC_RSP_OP(cmd, 6, 0, 64, uint64_t, (stat)->counter6); \
 } while (0)
 
 enum net_prot {
@@ -645,6 +432,33 @@ int dpni_close(struct fsl_mc_io	*mc_io,
 #define DPNI_OPT_FS_MASK_SUPPORT		0x00040000
 
 /**
+ * enum dpni_queue_type - Identifies a type of queue targeted by the command
+ * @DPNI_QUEUE_RX: Rx queue
+ * @DPNI_QUEUE_TX: Tx queue
+ * @DPNI_QUEUE_TX_CONFIRM: Tx confirmation queue
+ * @DPNI_QUEUE_RX_ERR: Rx error queue
+ */
+enum dpni_queue_type {
+	DPNI_QUEUE_RX,
+	DPNI_QUEUE_TX,
+	DPNI_QUEUE_TX_CONFIRM,
+	DPNI_QUEUE_RX_ERR,
+};
+
+struct dpni_cfg {
+		uint8_t mac_addr[6];
+	struct {
+		uint32_t		options;
+		uint16_t		fs_entries;
+		uint8_t			num_queues;
+		uint8_t			num_tcs;
+		uint8_t			mac_entries;
+		uint8_t			vlan_entries;
+		uint8_t			qos_entries;
+	} adv;
+};
+
+/**
  * struct dpni_extended_cfg - Structure representing extended DPNI configuration
  * @tc_cfg: TCs configuration
  * @ipr_cfg: IP reassembly configuration
@@ -685,78 +499,21 @@ struct dpni_extended_cfg {
 };
 
 /**
- * dpni_prepare_extended_cfg() - function prepare extended parameters
- * @cfg: extended structure
- * @ext_cfg_buf: Zeroed 256 bytes of memory before mapping it to DMA
+ * dpni_prepare_cfg() - function prepare parameters
+ * @cfg: cfg structure
+ * @cfg_buf: Zeroed 256 bytes of memory before mapping it to DMA
  *
  * This function has to be called before dpni_create()
  */
-int dpni_prepare_extended_cfg(const struct dpni_extended_cfg	*cfg,
-			      uint8_t			*ext_cfg_buf);
-
-/**
- * struct dpni_cfg - Structure representing DPNI configuration
- * @mac_addr: Primary MAC address
- * @adv: Advanced parameters; default is all zeros;
- *		use this structure to change default settings
- */
-struct dpni_cfg {
-	uint8_t mac_addr[6];
-	/**
-	 * struct adv - Advanced parameters
-	 * @options: Mask of available options; use 'DPNI_OPT_<X>' values
-	 * @start_hdr: Selects the packet starting header for parsing;
-	 *		'NET_PROT_NONE' is treated as default: 'NET_PROT_ETH'
-	 * @max_senders: Maximum number of different senders; used as the number
-	 *		of dedicated Tx flows; Non-power-of-2 values are rounded
-	 *		up to the next power-of-2 value as hardware demands it;
-	 *		'0' will be treated as '1'
-	 * @max_tcs: Maximum number of traffic classes (for both Tx and Rx);
-	 *		'0' will e treated as '1'
-	 * @max_unicast_filters: Maximum number of unicast filters;
-	 *			'0' is treated	as '16'
-	 * @max_multicast_filters: Maximum number of multicast filters;
-	 *			'0' is treated as '64'
-	 * @max_qos_entries: if 'max_tcs > 1', declares the maximum entries in
-	 *			the QoS	table; '0' is treated as '64'
-	 * @max_qos_key_size: Maximum key size for the QoS look-up;
-	 *			'0' is treated as '24' which is enough for IPv4
-	 *			5-tuple
-	 * @max_dist_key_size: Maximum key size for the distribution;
-	 *		'0' is treated as '24' which is enough for IPv4 5-tuple
-	 * @max_policers: Maximum number of policers;
-	 *		should be between '0' and max_tcs
-	 * @max_congestion_ctrl: Maximum number of congestion control groups
-	 *		(CGs); covers early drop and congestion notification
-	 *		requirements;
-	 *		should be between '0' and ('max_tcs' + 'max_senders')
-	 * @ext_cfg_iova: I/O virtual address of 256 bytes DMA-able memory
-	 *		filled with the extended configuration by calling
-	 *		dpni_prepare_extended_cfg()
-	 */
-	struct {
-		uint32_t		options;
-		enum net_prot		start_hdr;
-		uint8_t		max_senders;
-		uint8_t		max_tcs;
-		uint8_t		max_unicast_filters;
-		uint8_t		max_multicast_filters;
-		uint8_t			max_vlan_filters;
-		uint8_t		max_qos_entries;
-		uint8_t		max_qos_key_size;
-		uint8_t		max_dist_key_size;
-		uint8_t		max_policers;
-		uint8_t		max_congestion_ctrl;
-		uint64_t	ext_cfg_iova;
-	} adv;
-};
-
+int dpni_prepare_cfg(const struct dpni_cfg	*cfg,
+		     uint8_t			*cfg_buf);
 /**
  * dpni_create() - Create the DPNI object
  * @mc_io:	Pointer to MC portal's I/O object
+ * @token:	Authentication token.
  * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @cfg:	Configuration structure
- * @token:	Returned token; use in subsequent API calls
+ * @obj_id:	Returned obj_id; use in subsequent API calls
  *
  * Create the DPNI object, allocate required resources and
  * perform required initialization.
@@ -774,21 +531,24 @@ struct dpni_cfg {
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpni_create(struct fsl_mc_io	*mc_io,
+		uint16_t		token,
 		uint32_t		cmd_flags,
 		const struct dpni_cfg	*cfg,
-		uint16_t		*token);
+		uint32_t		*obj_id);
 
 /**
  * dpni_destroy() - Destroy the DPNI object and release all its resources.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @token:	Authentication token.
  * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
- * @token:	Token of DPNI object
+ * @obj_id:	Returned obj_id; use in subsequent API calls
  *
  * Return:	'0' on Success; error code otherwise.
  */
 int dpni_destroy(struct fsl_mc_io	*mc_io,
+		 uint16_t		token,
 		 uint32_t		cmd_flags,
-		 uint16_t		token);
+		 uint32_t		obj_id);
 
 /**
  * struct dpni_pools_cfg - Structure representing buffer pools configuration
@@ -867,49 +627,32 @@ int dpni_reset(struct fsl_mc_io	*mc_io,
 
 /**
  * struct dpni_attr - Structure representing DPNI attributes
- * @id: DPNI object ID
- * @version: DPNI version
- * @start_hdr: Indicates the packet starting header for parsing
  * @options: Mask of available options; reflects the value as was given in
  *		object's creation
- * @max_senders: Maximum number of different senders; used as the number
- *		of dedicated Tx flows;
- * @max_tcs: Maximum number of traffic classes (for both Tx and Rx)
+ * @max_num_queues: Number of queues available (for both Tx and Rx)
+ * @max_num_tcs: Maximum number of traffic classes (for both Tx and Rx)
+ * @max_mac_entries: Maximum number of traffic classes (for both Tx and Rx)
  * @max_unicast_filters: Maximum number of unicast filters
  * @max_multicast_filters: Maximum number of multicast filters
- * @max_vlan_filters: Maximum number of VLAN filters
+ * @max_vlan_entries: Maximum number of VLAN filters
  * @max_qos_entries: if 'max_tcs > 1', declares the maximum entries in QoS table
+ * @max_fs_entries: declares the maximum entries in flow steering table
  * @max_qos_key_size: Maximum key size for the QoS look-up
- * @max_dist_key_size: Maximum key size for the distribution look-up
- * @max_policers: Maximum number of policers;
- * @max_congestion_ctrl: Maximum number of congestion control groups (CGs);
- * @ext_cfg_iova: I/O virtual address of 256 bytes DMA-able memory;
- *	call dpni_extract_extended_cfg() to extract the extended configuration
+ * @max_fs_key_size: Maximum key size for the flow steering
+ * @wriop_version: Indicates revision of WRIOP hardware block
  */
 struct dpni_attr {
-	int id;
-	/**
-	 * struct version - DPNI version
-	 * @major: DPNI major version
-	 * @minor: DPNI minor version
-	 */
-	struct {
-		uint16_t major;
-		uint16_t minor;
-	} version;
-	enum net_prot start_hdr;
+	uint32_t id;
 	uint32_t options;
-	uint8_t max_senders;
-	uint8_t max_tcs;
-	uint8_t max_unicast_filters;
-	uint8_t max_multicast_filters;
-	uint8_t max_vlan_filters;
+	uint8_t max_num_queues;
+	uint8_t max_num_tcs;
+	uint8_t max_mac_entries;
+	uint8_t max_vlan_entries;
 	uint8_t max_qos_entries;
+	uint16_t max_fs_entries;
 	uint8_t max_qos_key_size;
-	uint8_t max_dist_key_size;
-	uint8_t max_policers;
-	uint8_t max_congestion_ctrl;
-	uint64_t	ext_cfg_iova;
+	uint8_t max_fs_key_size;
+	uint16_t wriop_version;
 };
 
 /**
@@ -927,14 +670,14 @@ int dpni_get_attributes(struct fsl_mc_io	*mc_io,
 			struct dpni_attr	*attr);
 
 /**
- * dpni_extract_extended_cfg() - extract the extended parameters
- * @cfg: extended structure
- * @ext_cfg_buf: 256 bytes of DMA-able memory
+ * dpni_extract_cfg() - extract the parameters
+ * @cfg: cfg structure
+ * @cfg_buf: 256 bytes of DMA-able memory
  *
  * This function has to be called after dpni_get_attributes()
  */
-int dpni_extract_extended_cfg(struct dpni_extended_cfg	*cfg,
-			      const uint8_t		*ext_cfg_buf);
+int dpni_extract_cfg(struct dpni_cfg	*cfg,
+		     const uint8_t	*cfg_buf);
 
 /**
  * DPNI errors
@@ -1037,7 +780,7 @@ int dpni_set_errors_behavior(struct fsl_mc_io		*mc_io,
  * @data_tail_room: Data tail room
  */
 struct dpni_buffer_layout {
-	uint32_t options;
+	uint16_t options;
 	int pass_timestamp;
 	int pass_parser_result;
 	int pass_frame_status;
@@ -1048,96 +791,38 @@ struct dpni_buffer_layout {
 };
 
 /**
- * dpni_get_rx_buffer_layout() - Retrieve Rx buffer layout attributes.
+ * dpni_get_buffer_layout() - Retrieve buffer layout attributes.
  * @mc_io:	Pointer to MC portal's I/O object
  * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @layout:	Returns buffer layout attributes
+ * @type:	DPNI queue type
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpni_get_rx_buffer_layout(struct fsl_mc_io		*mc_io,
-			      uint32_t			cmd_flags,
-			      uint16_t			token,
-			      struct dpni_buffer_layout	*layout);
+int dpni_get_buffer_layout(struct fsl_mc_io			*mc_io,
+			   uint32_t				cmd_flags,
+			   uint16_t				token,
+			   const struct dpni_buffer_layout	*layout,
+			   enum dpni_queue_type			type);
 
 /**
- * dpni_set_rx_buffer_layout() - Set Rx buffer layout configuration.
+ * dpni_set_buffer_layout() - Set buffer layout configuration.
  * @mc_io:	Pointer to MC portal's I/O object
  * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @layout:	Buffer layout configuration
+ * @type:	DPNI queue type
  *
  * Return:	'0' on Success; Error code otherwise.
  *
  * @warning	Allowed only when DPNI is disabled
  */
-int dpni_set_rx_buffer_layout(struct fsl_mc_io			*mc_io,
-			      uint32_t				cmd_flags,
-			      uint16_t				token,
-			      const struct dpni_buffer_layout	*layout);
-
-/**
- * dpni_get_tx_buffer_layout() - Retrieve Tx buffer layout attributes.
- * @mc_io:	Pointer to MC portal's I/O object
- * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
- * @token:	Token of DPNI object
- * @layout:	Returns buffer layout attributes
- *
- * Return:	'0' on Success; Error code otherwise.
- */
-int dpni_get_tx_buffer_layout(struct fsl_mc_io		*mc_io,
-			      uint32_t			cmd_flags,
-			      uint16_t			token,
-			      struct dpni_buffer_layout	*layout);
-
-/**
- * dpni_set_tx_buffer_layout() - Set Tx buffer layout configuration.
- * @mc_io:	Pointer to MC portal's I/O object
- * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
- * @token:	Token of DPNI object
- * @layout:	Buffer layout configuration
- *
- * Return:	'0' on Success; Error code otherwise.
- *
- * @warning	Allowed only when DPNI is disabled
- */
-int dpni_set_tx_buffer_layout(struct fsl_mc_io			*mc_io,
-			      uint32_t				cmd_flags,
-			      uint16_t				token,
-			      const struct dpni_buffer_layout	*layout);
-
-/**
- * dpni_get_tx_conf_buffer_layout() - Retrieve Tx confirmation buffer layout
- *				attributes.
- * @mc_io:	Pointer to MC portal's I/O object
- * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
- * @token:	Token of DPNI object
- * @layout:	Returns buffer layout attributes
- *
- * Return:	'0' on Success; Error code otherwise.
- */
-int dpni_get_tx_conf_buffer_layout(struct fsl_mc_io		*mc_io,
-				   uint32_t			cmd_flags,
-				   uint16_t			token,
-				   struct dpni_buffer_layout	*layout);
-
-/**
- * dpni_set_tx_conf_buffer_layout() - Set Tx confirmation buffer layout
- *					configuration.
- * @mc_io:	Pointer to MC portal's I/O object
- * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
- * @token:	Token of DPNI object
- * @layout:	Buffer layout configuration
- *
- * Return:	'0' on Success; Error code otherwise.
- *
- * @warning	Allowed only when DPNI is disabled
- */
-int dpni_set_tx_conf_buffer_layout(struct fsl_mc_io		   *mc_io,
-				   uint32_t			   cmd_flags,
-				   uint16_t			   token,
-				   const struct dpni_buffer_layout *layout);
+int dpni_set_buffer_layout(struct fsl_mc_io			*mc_io,
+			   uint32_t				cmd_flags,
+			   uint16_t				token,
+			   const struct dpni_buffer_layout	*layout,
+			   enum dpni_queue_type			type);
 
 /**
  * dpni_get_qdid() - Get the Queuing Destination ID (QDID) that should be used
@@ -1169,68 +854,6 @@ int dpni_get_tx_data_offset(struct fsl_mc_io	*mc_io,
 			    uint16_t		token,
 			    uint16_t		*data_offset);
 
-/**
- * enum dpni_counter - DPNI counter types
- * @DPNI_CNT_ING_FRAME: Counts ingress frames
- * @DPNI_CNT_ING_BYTE: Counts ingress bytes
- * @DPNI_CNT_ING_FRAME_DROP: Counts ingress frames dropped due to explicit
- *		'drop' setting
- * @DPNI_CNT_ING_FRAME_DISCARD: Counts ingress frames discarded due to errors
- * @DPNI_CNT_ING_MCAST_FRAME: Counts ingress multicast frames
- * @DPNI_CNT_ING_MCAST_BYTE: Counts ingress multicast bytes
- * @DPNI_CNT_ING_BCAST_FRAME: Counts ingress broadcast frames
- * @DPNI_CNT_ING_BCAST_BYTES: Counts ingress broadcast bytes
- * @DPNI_CNT_EGR_FRAME: Counts egress frames
- * @DPNI_CNT_EGR_BYTE: Counts egress bytes
- * @DPNI_CNT_EGR_FRAME_DISCARD: Counts egress frames discarded due to errors
- */
-enum dpni_counter {
-	DPNI_CNT_ING_FRAME = 0x0,
-	DPNI_CNT_ING_BYTE = 0x1,
-	DPNI_CNT_ING_FRAME_DROP = 0x2,
-	DPNI_CNT_ING_FRAME_DISCARD = 0x3,
-	DPNI_CNT_ING_MCAST_FRAME = 0x4,
-	DPNI_CNT_ING_MCAST_BYTE = 0x5,
-	DPNI_CNT_ING_BCAST_FRAME = 0x6,
-	DPNI_CNT_ING_BCAST_BYTES = 0x7,
-	DPNI_CNT_EGR_FRAME = 0x8,
-	DPNI_CNT_EGR_BYTE = 0x9,
-	DPNI_CNT_EGR_FRAME_DISCARD = 0xa
-};
-
-/**
- * dpni_get_counter() - Read a specific DPNI counter
- * @mc_io:	Pointer to MC portal's I/O object
- * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
- * @token:	Token of DPNI object
- * @counter:	The requested counter
- * @value:	Returned counter's current value
- *
- * Return:	'0' on Success; Error code otherwise.
- */
-int dpni_get_counter(struct fsl_mc_io	*mc_io,
-		     uint32_t		cmd_flags,
-		     uint16_t		token,
-		     enum dpni_counter	counter,
-		     uint64_t		*value);
-
-/**
- * dpni_set_counter() - Set (or clear) a specific DPNI counter
- * @mc_io:	Pointer to MC portal's I/O object
- * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
- * @token:	Token of DPNI object
- * @counter:	The requested counter
- * @value:	New counter value; typically pass '0' for resetting
- *			the counter.
- *
- * Return:	'0' on Success; Error code otherwise.
- */
-int dpni_set_counter(struct fsl_mc_io	*mc_io,
-		     uint32_t		cmd_flags,
-		     uint16_t		token,
-		     enum dpni_counter	counter,
-		     uint64_t		value);
-
 /* Enable auto-negotiation */
 #define DPNI_LINK_OPT_AUTONEG		0x0000000000000001ULL
 /* Enable half-duplex mode */
@@ -1506,183 +1129,199 @@ struct dpni_queue_attr {
 #define DPNI_TX_FLOW_OPT_L4_CHKSUM_GEN	0x00000020
 
 /**
- * struct dpni_tx_flow_cfg - Structure representing Tx flow configuration
- * @options: Flags representing the suggested modifications to the Tx flow;
- *	Use any combination 'DPNI_TX_FLOW_OPT_<X>' flags
- * @use_common_tx_conf_queue: Set to '1' to use the common (default) Tx
- *	confirmation and error queue; Set to '0' to use the private
- *	Tx confirmation and error queue; valid only if
- *	'DPNI_OPT_PRIVATE_TX_CONF_ERROR_DISABLED' wasn't set at DPNI creation
- *	and 'DPNI_TX_FLOW_OPT_TX_CONF_ERROR' is contained in 'options'
- * @l3_chksum_gen: Set to '1' to enable L3 checksum generation; '0' to disable;
- *	valid only if 'DPNI_TX_FLOW_OPT_L3_CHKSUM_GEN' is contained in 'options'
- * @l4_chksum_gen: Set to '1' to enable L4 checksum generation; '0' to disable;
- *	valid only if 'DPNI_TX_FLOW_OPT_L4_CHKSUM_GEN' is contained in 'options'
- */
-struct dpni_tx_flow_cfg {
-	uint32_t	options;
-	int		use_common_tx_conf_queue;
-	int		l3_chksum_gen;
-	int		l4_chksum_gen;
-};
-
-/**
- * dpni_set_tx_flow() - Set Tx flow configuration
+ * dpni_get_api_version - Retrieve DPNI Major and Minor version info.
+ *
  * @mc_io:	Pointer to MC portal's I/O object
  * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
- * @token:	Token of DPNI object
- * @flow_id:	Provides (or returns) the sender's flow ID;
- *	for each new sender set (*flow_id) to 'DPNI_NEW_FLOW_ID' to generate
- *	a new flow_id;	this ID should be used as the QDBIN argument
- *	in enqueue operations
- * @cfg:	Tx flow configuration
+ * @major_ver:	DPNI major version
+ * @minor_ver:	DPNI minor version
  *
- * Return:	'0' on Success; Error code otherwise.
- */
-int dpni_set_tx_flow(struct fsl_mc_io			*mc_io,
-		     uint32_t				cmd_flags,
-		     uint16_t				token,
-		     uint16_t				*flow_id,
-		     const struct dpni_tx_flow_cfg	*cfg);
-
-/**
- * struct dpni_tx_flow_attr - Structure representing Tx flow attributes
- * @use_common_tx_conf_queue: '1' if using common (default) Tx confirmation and
- *	error queue; '0' if using private Tx confirmation and error queue
- * @l3_chksum_gen: '1' if L3 checksum generation is enabled; '0' if disabled
- * @l4_chksum_gen: '1' if L4 checksum generation is enabled; '0' if disabled
- */
-struct dpni_tx_flow_attr {
-	int	use_common_tx_conf_queue;
-	int	l3_chksum_gen;
-	int	l4_chksum_gen;
+ * Return:     '0' on Success; Error code otherwise.
+ */
+int dpni_get_api_version(struct fsl_mc_io *mc_io,
+			 u32 cmd_flags,
+			 u16 *major_ver,
+			 u16 *minor_ver);
+
+/**
+ * enum dpni_confirmation_mode - Defines DPNI options supported for Tx
+ * confirmation
+ * @DPNI_CONF_AFFINE: For each Tx queue set associated with a sender there is
+ * an affine Tx Confirmation queue
+ * @DPNI_CONF_SINGLE: All Tx queues are associated with a single Tx
+ * confirmation queue
+ * @DPNI_CONF_DISABLE: Tx frames are not confirmed.  This must be associated
+ * with proper FD set-up to have buffers release to a Buffer Pool, otherwise
+ * buffers will be leaked.
+ */
+enum dpni_confirmation_mode {
+	DPNI_CONF_AFFINE,
+	DPNI_CONF_SINGLE,
+	DPNI_CONF_DISABLE,
 };
 
-/**
- * dpni_get_tx_flow() - Get Tx flow attributes
- * @mc_io:	Pointer to MC portal's I/O object
- * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
- * @token:	Token of DPNI object
- * @flow_id:	The sender's flow ID, as returned by the
- *	dpni_set_tx_flow() function
- * @attr:	Returned Tx flow attributes
- *
- * Return:	'0' on Success; Error code otherwise.
- */
-int dpni_get_tx_flow(struct fsl_mc_io		*mc_io,
-		     uint32_t			cmd_flags,
-		     uint16_t			token,
-		     uint16_t			flow_id,
-		     struct dpni_tx_flow_attr	*attr);
+struct dpni_tx_confirmation_mode {
+	uint32_t pad;
+	uint8_t confirmation_mode;
+};
 
 /**
- * struct dpni_tx_conf_cfg - Structure representing Tx conf configuration
- * @errors_only: Set to '1' to report back only error frames;
- *	Set to '0' to confirm transmission/error for all transmitted frames;
- * @queue_cfg: Queue configuration
+ * struct dpni_queue - Queue structure
+ * @fqid:  FQID used for enqueueing to and/or configuration of this specific FQ
+ * @qdbin: Queueing bin, used to enqueue using QDID, DQBIN, QPRI. Only relevant
+ *         for Tx queues.
+ * @flc:   FLC value for traffic dequeued from this queue.
+ * @user_context:    User data, presented to the user along with any frames
+ *                   from this queue. Not relevant for Tx queues.
  */
-struct dpni_tx_conf_cfg {
-	int			errors_only;
-	struct dpni_queue_cfg	queue_cfg;
+struct dpni_queue {
+	/**
+	* struct destination - Destination structure
+	* @id:   ID of the destination, only relevant if DEST_TYPE is > 0.
+	*        Identifies either a DPIO or a DPCON object. Not relevant for Tx
+	*        queues.
+	* @type: May be one of the following:
+	*         0 - No destination, queue can be manually queried, but won't
+	*             push traffic or notifications to a DPIO;
+	*         1 - The destination is DPIO. When traffic becomes available in
+	*             the queue a FQDAN (FQ data available notification) will be
+	*             generated to selected DPIO;
+	*         2 - The destination is a DPCON. The queue is associated with a
+	*             DPCON object for purpose of scheduling between multiple
+	*             queues. The DPCON may be independently configured to
+	*             generate notifications. Not relevant for Tx queues.
+	* @hold_active: Hold active
+	*/
+	struct {
+		uint32_t id;
+		enum dpni_dest type;
+		char hold_active;
+		char stash_ctrl;
+	} destination;
+	uint8_t  options;
+	uint32_t fqid;
+	uint16_t qdbin;
+	uint64_t flc;
+	uint64_t user_context;
 };
 
 /**
- * dpni_set_tx_conf() - Set Tx confirmation and error queue configuration
- * @mc_io:	Pointer to MC portal's I/O object
- * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
- * @token:	Token of DPNI object
- * @flow_id:	The sender's flow ID, as returned by the
- *	dpni_set_tx_flow() function;
- *	use 'DPNI_COMMON_TX_CONF' for common tx-conf
- * @cfg:	Queue configuration
+ * dpni_set_queue() - Set queue parameters
+ * @mc_io:      Pointer to MC portal's I/O object
+ * @cmd_flags:  Command flags; one or more of 'MC_CMD_FLAG_'
+ * @token:      Token of DPNI object
+ * @type:       Type of queue
+ * @tc:         Traffic class, in range 0 to NUM_TCS - 1
+ * @index:      Selects the specific queue out of the set allocated for the same
+ *              TC. Value must be in range 0 to NUM_QUEUES - 1
+ * @queue:      Queue structure
  *
- * If either 'DPNI_OPT_TX_CONF_DISABLED' or
- * 'DPNI_OPT_PRIVATE_TX_CONF_ERROR_DISABLED' were selected at DPNI creation,
- * this function can ONLY be used with 'flow_id == DPNI_COMMON_TX_CONF';
- * i.e. only serve the common tx-conf-err queue;
- * if 'DPNI_OPT_TX_CONF_DISABLED' was selected, only error frames are reported
- * back - successfully transmitted frames are not confirmed. Otherwise, all
- * transmitted frames are sent for confirmation.
+ * Return:     '0' on Success; Error code otherwise.
+ */
+int dpni_set_queue(struct fsl_mc_io		*mc_io,
+		   uint32_t			cmd_flags,
+		   uint16_t			token,
+		   enum dpni_queue_type		type,
+		   uint8_t			tc,
+		   uint8_t			index,
+		   const struct dpni_queue	*queue);
+
+/**
+ * dpni_get_queue() - Get queue parameters
+ * @mc_io:      Pointer to MC portal's I/O object
+ * @cmd_flags:  Command flags; one or more of 'MC_CMD_FLAG_'
+ * @token:      Token of DPNI object
+ * @type:       Type of queue
+ * @tc:         Traffic class, in range 0 to NUM_TCS - 1
+ * @index:      Selects the specific queue out of the set allocated for the same
+ *              TC. Value must be in range 0 to NUM_QUEUES - 1
+ * @queue:      Queue structure
  *
- * Return:	'0' on Success; Error code otherwise.
+ * Return:      '0' on Success; Error code otherwise.
  */
-int dpni_set_tx_conf(struct fsl_mc_io	*mc_io,
-		     uint32_t		cmd_flags,
-		     uint16_t		token,
-		     uint16_t		flow_id,
-		     const struct dpni_tx_conf_cfg	*cfg);
+int dpni_get_queue(struct fsl_mc_io		*mc_io,
+		   uint32_t			cmd_flags,
+		   uint16_t			token,
+		   enum dpni_queue_type		type,
+		   uint8_t			tc,
+		   uint8_t			index,
+		   struct dpni_queue		*queue);
 
 /**
- * struct dpni_tx_conf_attr - Structure representing Tx conf attributes
- * @errors_only: '1' if only error frames are reported back; '0' if all
- *		transmitted frames are confirmed
- * @queue_attr: Queue attributes
+ * dpni_set_tx_confirmation_mode() - Set TX conf mode
+ * @mc_io:      Pointer to MC portal's I/O object
+ * @cmd_flags:  Command flags; one or more of 'MC_CMD_FLAG_'
+ * @token:      Token of DPNI object
+ * @mode:       DPNI confirmation mode type
+ *
+ * Return:      '0' on Success; Error code otherwise.
  */
-struct dpni_tx_conf_attr {
-	int			errors_only;
-	struct dpni_queue_attr	queue_attr;
+int dpni_set_tx_confirmation_mode(struct fsl_mc_io	*mc_io,
+				  uint32_t		cmd_flags,
+				  uint16_t		token,
+				  enum dpni_confirmation_mode mode);
+struct dpni_statistics {
+	/**
+	 * Page_0 statistics structure
+	 * @ingress_all_frames: Ingress frame count
+	 * @ingress_all_bytes: Ingress byte count
+	 * @ingress_multicast_frames: Ingress multicast frame count
+	 * @ingress_multicast_bytes: Ingress multicast byte count
+	 * @ingress_broadcast_frames: Ingress broadcast frame count
+	 * @ingress_broadcast_bytes: Ingress broadcast byte count
+	 *
+	 * Page_1 statistics structure
+	 * @egress_all_frames: Egress frame count
+	 * @egress_all_bytes: Egress byte count
+	 * @egress_multicast_frames: Egress multicast frame count
+	 * @egress_multicast_bytes: Egress multicast byte count
+	 * @egress_broadcast_frames: Egress broadcast frame count
+	 * @egress_broadcast_bytes: Egress broadcast byte count
+	 *
+	 * Page_2 statistics structure
+	 * @ingress_filtered_frames: Ingress filtered frame count
+	 * @ingress_discarded_frames: Ingress discarded frame count
+	 * @ingress_nobuffer_discards: Ingress discarded frame count due to
+	 *  lack of buffers.
+	 * @egress_discarded_frames: Egress discarded frame count
+	 * @egress_confirmed_frames: Egress confirmed frame count
+	 */
+
+	uint64_t counter0;
+	uint64_t counter1;
+	uint64_t counter2;
+	uint64_t counter3;
+	uint64_t counter4;
+	uint64_t counter5;
+	uint64_t counter6;
 };
 
 /**
- * dpni_get_tx_conf() - Get Tx confirmation and error queue attributes
+ * dpni_get_statistics() - Get DPNI statistics
  * @mc_io:	Pointer to MC portal's I/O object
  * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
- * @flow_id:	The sender's flow ID, as returned by the
- *	dpni_set_tx_flow() function;
- *	use 'DPNI_COMMON_TX_CONF' for common tx-conf
- * @attr:	Returned tx-conf attributes
- *
- * If either 'DPNI_OPT_TX_CONF_DISABLED' or
- * 'DPNI_OPT_PRIVATE_TX_CONF_ERROR_DISABLED' were selected at DPNI creation,
- * this function can ONLY be used with 'flow_id == DPNI_COMMON_TX_CONF';
- * i.e. only serve the common tx-conf-err queue;
+ * @page:	Selects the statistics page to retrieve, see DPNI_GET_STATISTICS
+ *		output. Pages are numbered 0 to 2.
+ * @stat:	Structure containing the statistics
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpni_get_tx_conf(struct fsl_mc_io	*mc_io,
-		     uint32_t		cmd_flags,
-		     uint16_t		token,
-		     uint16_t		flow_id,
-		     struct dpni_tx_conf_attr	*attr);
-/**
- * dpni_set_rx_flow() - Set Rx flow configuration
- * @mc_io:	Pointer to MC portal's I/O object
- * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
- * @token:	Token of DPNI object
- * @tc_id:	Traffic class selection (0-7);
- *			use 'DPNI_ALL_TCS' to set all TCs and all flows
- * @flow_id:	Rx flow id within the traffic class; use
- *			'DPNI_ALL_TC_FLOWS' to set all flows within
- *			this tc_id; ignored if tc_id is set to
- *			'DPNI_ALL_TCS';
- * @cfg:	Rx flow configuration
- *
- * Return:	'0' on Success; Error code otherwise.
- */
-int dpni_set_rx_flow(struct fsl_mc_io			*mc_io,
-		     uint32_t				cmd_flags,
-		     uint16_t				token,
-		     uint8_t				tc_id,
-		     uint16_t				flow_id,
-		     const struct dpni_queue_cfg	*cfg);
+int dpni_get_statistics(struct fsl_mc_io *mc_io,
+			uint32_t cmd_flags,
+			uint16_t token,
+			uint8_t page,
+			struct dpni_statistics *stat);
 
 /**
- * dpni_get_rx_flow() -	Get Rx flow attributes
+ * dpni_reset_statistics() - Clears DPNI statistics
  * @mc_io:	Pointer to MC portal's I/O object
  * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
- * @tc_id:	Traffic class selection (0-7)
- * @flow_id:	Rx flow id within the traffic class
- * @attr:	Returned Rx flow attributes
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpni_get_rx_flow(struct fsl_mc_io		*mc_io,
-		     uint32_t			cmd_flags,
-		     uint16_t			token,
-		     uint8_t			tc_id,
-		     uint16_t			flow_id,
-		     struct dpni_queue_attr	*attr);
-
+int dpni_reset_statistics(struct fsl_mc_io *mc_io,
+			  uint32_t cmd_flags,
+			  uint16_t token);
 #endif /* _FSL_DPNI_H */
diff --git a/include/fsl-mc/fsl_dprc.h b/include/fsl-mc/fsl_dprc.h
index 535c789..8ad01d4 100644
--- a/include/fsl-mc/fsl_dprc.h
+++ b/include/fsl-mc/fsl_dprc.h
@@ -1,8 +1,8 @@
 /*
  * Freescale Layerscape MC I/O wrapper
  *
- * Copyright (C) 2013-2015 Freescale Semiconductor, Inc.
- * Author: German Rivera <German.Rivera@freescale.com>
+ * Copyright (C) 2013-2016 Freescale Semiconductor, Inc.
+ * Copyright 2017 NXP
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -10,29 +10,30 @@
 #define _FSL_DPRC_H
 
 /* DPRC Version */
-#define DPRC_VER_MAJOR				5
+#define DPRC_VER_MAJOR				6
 #define DPRC_VER_MINOR				1
 
 /* Command IDs */
-#define DPRC_CMDID_CLOSE			0x800
-#define DPRC_CMDID_OPEN				0x805
-#define DPRC_CMDID_CREATE			0x905
-
-#define DPRC_CMDID_GET_ATTR			0x004
-#define DPRC_CMDID_RESET_CONT			0x005
-
-#define DPRC_CMDID_CREATE_CONT			0x151
-#define DPRC_CMDID_DESTROY_CONT			0x152
-#define DPRC_CMDID_GET_CONT_ID			0x830
-#define DPRC_CMDID_GET_OBJ_COUNT		0x159
-#define DPRC_CMDID_GET_OBJ			0x15A
-#define DPRC_CMDID_GET_RES_COUNT		0x15B
-#define DPRC_CMDID_GET_RES_IDS			0x15C
-#define DPRC_CMDID_GET_OBJ_REG			0x15E
-
-#define DPRC_CMDID_CONNECT			0x167
-#define DPRC_CMDID_DISCONNECT			0x168
-#define DPRC_CMDID_GET_CONNECTION		0x16C
+#define DPRC_CMDID_CLOSE			0x8001
+#define DPRC_CMDID_OPEN				0x8051
+#define DPRC_CMDID_CREATE			0x9051
+
+#define DPRC_CMDID_GET_ATTR			0x0041
+#define DPRC_CMDID_RESET_CONT			0x0051
+#define DPRC_CMDID_GET_API_VERSION              0xa051
+
+#define DPRC_CMDID_CREATE_CONT			0x1511
+#define DPRC_CMDID_DESTROY_CONT			0x1521
+#define DPRC_CMDID_GET_CONT_ID			0x8301
+#define DPRC_CMDID_GET_OBJ_COUNT		0x1591
+#define DPRC_CMDID_GET_OBJ			0x15A1
+#define DPRC_CMDID_GET_RES_COUNT		0x15B1
+#define DPRC_CMDID_GET_RES_IDS			0x15C1
+#define DPRC_CMDID_GET_OBJ_REG			0x15E1
+
+#define DPRC_CMDID_CONNECT			0x1671
+#define DPRC_CMDID_DISCONNECT			0x1681
+#define DPRC_CMDID_GET_CONNECTION		0x16C1
 
 /*                cmd, param, offset, width, type, arg_name */
 #define DPRC_RSP_GET_CONTAINER_ID(cmd, container_id) \
@@ -88,8 +89,6 @@ do { \
 	MC_RSP_OP(cmd, 0, 32, 16, uint16_t, attr->icid); \
 	MC_RSP_OP(cmd, 1, 0,  32, uint32_t, attr->options);\
 	MC_RSP_OP(cmd, 1, 32, 32, int,      attr->portal_id); \
-	MC_RSP_OP(cmd, 2, 0,  16, uint16_t, attr->version.major);\
-	MC_RSP_OP(cmd, 2, 16, 16, uint16_t, attr->version.minor);\
 } while (0)
 
 /*                cmd, param, offset, width, type, arg_name */
@@ -345,9 +344,9 @@ do { \
 #define DPRC_CMD_CONNECT(cmd, endpoint1, endpoint2, cfg) \
 do { \
 	MC_CMD_OP(cmd, 0, 0,  32, int,      endpoint1->id); \
-	MC_CMD_OP(cmd, 0, 32, 16, uint16_t, endpoint1->if_id); \
+	MC_CMD_OP(cmd, 0, 32, 32, int, endpoint1->if_id); \
 	MC_CMD_OP(cmd, 1, 0,  32, int,	    endpoint2->id); \
-	MC_CMD_OP(cmd, 1, 32, 16, uint16_t, endpoint2->if_id); \
+	MC_CMD_OP(cmd, 1, 32, 32, int, endpoint2->if_id); \
 	MC_CMD_OP(cmd, 2, 0,  8,  char,     endpoint1->type[0]); \
 	MC_CMD_OP(cmd, 2, 8,  8,  char,	    endpoint1->type[1]); \
 	MC_CMD_OP(cmd, 2, 16, 8,  char,	    endpoint1->type[2]); \
@@ -410,8 +409,8 @@ do { \
 /*                cmd, param, offset, width, type, arg_name */
 #define DPRC_CMD_GET_CONNECTION(cmd, endpoint1) \
 do { \
-	MC_CMD_OP(cmd, 0, 0,  32, int,      endpoint1->id); \
-	MC_CMD_OP(cmd, 0, 32, 16, uint16_t, endpoint1->if_id); \
+	MC_CMD_OP(cmd, 0, 0,  32, int,	    endpoint1->id); \
+	MC_CMD_OP(cmd, 0, 32, 32, int,	    endpoint1->if_id); \
 	MC_CMD_OP(cmd, 1, 0,  8,  char,     endpoint1->type[0]); \
 	MC_CMD_OP(cmd, 1, 8,  8,  char,	    endpoint1->type[1]); \
 	MC_CMD_OP(cmd, 1, 16, 8,  char,	    endpoint1->type[2]); \
@@ -657,15 +656,6 @@ struct dprc_attributes {
 	uint16_t icid;
 	int portal_id;
 	uint64_t options;
-	/**
-	 * struct version - DPRC version
-	 * @major: DPRC major version
-	 * @minor: DPRC minor version
-	 */
-	struct {
-		uint16_t major;
-		uint16_t minor;
-	} version;
 };
 
 /**
@@ -950,4 +940,19 @@ int dprc_get_connection(struct fsl_mc_io		*mc_io,
 			struct dprc_endpoint		*endpoint2,
 			int				*state);
 
+/**
+ * dprc_get_api_version - Retrieve DPRC Major and Minor version info.
+ *
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
+ * @major_ver:	DPRC major version
+ * @minor_ver:	DPRC minor version
+ *
+ * Return:     '0' on Success; Error code otherwise.
+ */
+int dprc_get_api_version(struct fsl_mc_io *mc_io,
+			 u32 cmd_flags,
+			 u16 *major_ver,
+			 u16 *minor_ver);
+
 #endif /* _FSL_DPRC_H */
diff --git a/include/fsl-mc/fsl_mc_cmd.h b/include/fsl-mc/fsl_mc_cmd.h
index f3d1498..1ec67b5 100644
--- a/include/fsl-mc/fsl_mc_cmd.h
+++ b/include/fsl-mc/fsl_mc_cmd.h
@@ -1,4 +1,5 @@
-/* Copyright 2013-2015 Freescale Semiconductor Inc.
+/* Copyright 2013-2016 Freescale Semiconductor Inc.
+ * Copyright 2017 NXP
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -24,6 +25,15 @@ struct mc_command {
 	uint64_t params[MC_CMD_NUM_OF_PARAMS];
 };
 
+struct mc_rsp_create {
+	__le32 object_id;
+};
+
+struct mc_rsp_api_ver {
+	__le16 major_ver;
+	__le16 minor_ver;
+};
+
 enum mc_cmd_status {
 	MC_CMD_STATUS_OK = 0x0, /*!< Completed successfully */
 	MC_CMD_STATUS_READY = 0x1, /*!< Ready to be processed */
@@ -51,15 +61,15 @@ enum mc_cmd_status {
 #define MC_CMD_FLAG_INTR_DIS	0x01000000
 
 
-#define MC_CMD_HDR_CMDID_O	52	/* Command ID field offset */
-#define MC_CMD_HDR_CMDID_S	12	/* Command ID field size */
+#define MC_CMD_HDR_CMDID_O	48	/* Command ID field offset */
+#define MC_CMD_HDR_CMDID_S	16	/* Command ID field size */
 #define MC_CMD_HDR_STATUS_O	16	/* Status field offset */
-#define MC_CMD_HDR_TOKEN_O	38	/* Token field offset */
-#define MC_CMD_HDR_TOKEN_S	10	/* Token field size */
+#define MC_CMD_HDR_TOKEN_O	32	/* Token field offset */
+#define MC_CMD_HDR_TOKEN_S	16	/* Token field size */
 #define MC_CMD_HDR_STATUS_S	8	/* Status field size*/
 #define MC_CMD_HDR_FLAGS_O	0	/* Flags field offset */
 #define MC_CMD_HDR_FLAGS_S	32	/* Flags field size*/
-#define MC_CMD_HDR_FLAGS_MASK	0xFF00FF00 /* Command flags mask */
+#define MC_CMD_HDR_FLAGS_MASK	0x0000FFFF /* Command flags mask */
 
 #define MC_CMD_HDR_READ_STATUS(_hdr) \
 	((enum mc_cmd_status)mc_dec((_hdr), \
@@ -80,11 +90,19 @@ enum mc_cmd_status {
 #define MC_RSP_OP(_cmd, _param, _offset, _width, _type, _arg) \
 	(_arg = (_type)mc_dec(_cmd.params[_param], (_offset), (_width)))
 
+/*                cmd, param, offset, width, type, arg_name */
+#define MC_CMD_READ_OBJ_ID(cmd, obj_id) \
+	MC_RSP_OP(cmd, 0, 0,  32,  uint32_t,	    obj_id)
+
+/* cmd, param, offset, width, type, arg_name */
+#define CMD_DESTROY_SET_OBJ_ID_PARAM0(cmd, object_id) \
+	MC_CMD_OP(cmd, 0, 0,  32,  uint32_t,  object_id)
+
 static inline uint64_t mc_encode_cmd_header(uint16_t cmd_id,
 					    uint32_t cmd_flags,
 					    uint16_t token)
 {
-	uint64_t hdr;
+	uint64_t hdr = 0;
 
 	hdr = mc_enc(MC_CMD_HDR_CMDID_O, MC_CMD_HDR_CMDID_S, cmd_id);
 	hdr |= mc_enc(MC_CMD_HDR_FLAGS_O, MC_CMD_HDR_FLAGS_S,
@@ -144,4 +162,22 @@ static inline enum mc_cmd_status mc_read_response(
 	return status;
 }
 
+/**
+ * mc_read_version - read version of the given cmd
+ *
+ * @cmd: pointer to a filled command
+ * @major_version: major version value for the given cmd
+ * @minor_version: minor version value for the given cmd
+ */
+static inline void mc_cmd_read_api_version(struct mc_command *cmd,
+					   u16 *major_ver,
+					   u16 *minor_ver)
+{
+	struct mc_rsp_api_ver *rsp_params;
+
+	rsp_params = (struct mc_rsp_api_ver *)cmd->params;
+	*major_ver = le16_to_cpu(rsp_params->major_ver);
+	*minor_ver = le16_to_cpu(rsp_params->minor_ver);
+}
+
 #endif /* __FSL_MC_CMD_H */
diff --git a/include/fsl-mc/fsl_mc_private.h b/include/fsl-mc/fsl_mc_private.h
index 17e0611..2932d9d 100644
--- a/include/fsl-mc/fsl_mc_private.h
+++ b/include/fsl-mc/fsl_mc_private.h
@@ -1,5 +1,6 @@
 /*
- * Copyright (C) 2014 Freescale Semiconductor
+ * Copyright (C) 2014-2016 Freescale Semiconductor
+ * Copyright 2017 NXP
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -29,6 +30,7 @@ extern struct fsl_mc_io *dflt_mc_io;
  * @struct dpbp_attr: DPBP attribute
  */
 struct fsl_dpbp_obj {
+	uint32_t dpbp_id;
 	uint16_t dpbp_handle;
 	struct dpbp_attr dpbp_attr;
 };
@@ -41,7 +43,7 @@ extern struct fsl_dpbp_obj *dflt_dpbp;
  * @struct qbman_swp *sw_portal: SW portal object
  */
 struct fsl_dpio_obj {
-	int dpio_id;
+	uint32_t dpio_id;
 	uint16_t dpio_handle;
 	struct qbman_swp *sw_portal; /** SW portal object */
 };
@@ -56,7 +58,7 @@ extern struct fsl_dpio_obj *dflt_dpio;
  * @struct dpni_buffer_layout: DPNI buffer layout
  */
 struct fsl_dpni_obj {
-	int dpni_id;
+	uint32_t dpni_id;
 	uint16_t dpni_handle;
 	struct dpni_attr dpni_attrs;
 	struct dpni_buffer_layout buf_layout;
-- 
1.7.1

